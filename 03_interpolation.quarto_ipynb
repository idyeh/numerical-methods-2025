{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"插值与近似\"\n",
        "---\n",
        "\n",
        "## 学习目标\n",
        "\n",
        "* 掌握**多项式插值**的三种经典表述：**拉格朗日型**、**牛顿型**、**重心公式**；理解它们在数值稳定性与代价上的区别。\n",
        "* 认识**节点选择**的重要性，能用**切比雪夫（Chebyshev）节点**缓解龙格（Runge）现象。\n",
        "* 理解并实现**三次样条插值**，比较其与高次多项式插值的稳定性与效果。\n",
        "* 具备**工程化**的实现能力：统一 API、单元自检、可视化误差与复杂度。\n",
        "\n",
        "## 背景\n",
        "- 当我们只在若干**离散点**上有数据或模型输出，但需要在这些点之间“填空”或平滑逼近时，就需要插值或近似。\n",
        "- 典型行业应用  \n",
        "  - **汽车/电池工程**：电池**开路电压（OCV）** 与荷电状态 **SoC** 的标定曲线（BMS 估算 SoC、热管理）；发动机/电机的**扭矩–转速**查表控制。  \n",
        "  - **金融**：**收益率曲线**与远期率从离散期限的债券/掉期报价**内插**到任意期限，用于定价与风险管理。  \n",
        "  - **航空航天/气象/地学**：格点场（风场、温度场、地形高程）的**空间内插**与重采样。  \n",
        "  - **计算机图形/信号处理**：图像缩放的双线性/双三次插值，音频**重采样**。  \n",
        "  - **实验科学/材料**：**标定曲线**（激光器电流–功率、材料应变–应力的弹性段）与数据清洗/反演。\n",
        "\n",
        "\n",
        "## 动机\n",
        "\n",
        "* **数据拟合与近似**：实验数据点 $(x_i,y_i)$ 的**光滑逼近**、数值微分/积分的内插、函数逼近的低阶局部模型。\n",
        "* **数值代数**：构造求积公式（Newton–Cotes、Gauss 类）时的插值思想。\n",
        "\n",
        "> 主线：**插值多项式阶数越高并不意味着更好**\n",
        "\n",
        "\n",
        "## 拉格朗日（Lagrange）型\n",
        "\n",
        "给定离散的**互异节点** $x_0,\\dots,x_n$，数据 $y_i=f(x_i)$，存在唯一的**至多 $n$ 次**多项式 $p_n$ 使 $p_n(x_i)=y_i$。\n",
        "\n",
        "构造基函数 $\\ell_i(x)$ 使 $\\ell_i(x_j)=\\delta_{ij}$。对互异节点 $x_0,\\dots,x_n$，定义\n",
        "$$\n",
        "\\ell_i(x)=\\prod_{\\substack{j=0 \\\\ j\\ne i}}^{n}\\frac{x-x_j}{x_i-x_j}.\n",
        "$$\n",
        "\n",
        "显然 $\\ell_i(x_j)=0$（$j\\ne i$）且 $\\ell_i(x_i)=1$。令\n",
        "$$\n",
        "p_n(x)=\\sum_{i=0}^{n} y_i\\,\\ell_i(x),\n",
        "$$\n",
        "\n",
        "则 $p_n(x_k)=\\sum_i y_i\\,\\ell_i(x_k)=y_k$。因“至多 $n$ 次多项式插值”的**唯一性**（维数或范德蒙德可逆性），该 $p_n$ 即为所求。\n",
        "\n",
        "::: callout-note\n",
        "直观、一次成型。但**直接计算**在数值上不稳（大量乘除）且**每次求值 $O(n^2)$**。\n",
        ":::\n",
        "\n",
        "### 误差项\n",
        "\n",
        "\n",
        "若 $f\\in C^{n+1}$，误差公式表示为：\n",
        "\n",
        "  $$\n",
        "  f(x)-p_n(x)=\\frac{f^{(n+1)}(\\xi_x)}{(n+1)!}\\,\\omega_{n+1}(x),\\qquad\n",
        "  \\omega_{n+1}(x)=\\prod_{i=0}^{n}(x-x_i).\n",
        "  $$\n",
        "\n",
        "$\\omega_{n+1}$ 的振幅控制说明**节点分布**对误差很重要。\n",
        "\n",
        "### 拉格朗日的直接实现"
      ],
      "id": "3b6c48f4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "\n",
        "def lagrange_eval(x_nodes, y_nodes, x):\n",
        "    x_nodes = np.asarray(x_nodes, dtype=np.float64)\n",
        "    y_nodes = np.asarray(y_nodes, dtype=np.float64)\n",
        "    x = np.atleast_1d(np.asarray(x, dtype=np.float64))\n",
        "    n = len(x_nodes) - 1\n",
        "    out = np.zeros_like(x)\n",
        "    for i in range(n + 1):\n",
        "        # 计算 ℓ_i(x)\n",
        "        li = np.ones_like(x)\n",
        "        for j in range(n + 1):\n",
        "            if j == i:\n",
        "                continue\n",
        "            li *= (x - x_nodes[j]) / (x_nodes[i] - x_nodes[j])\n",
        "        out += y_nodes[i] * li\n",
        "    return out if out.ndim else out.item()"
      ],
      "id": "b05fe516",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: callout-caution\n",
        "不推荐生产使用\n",
        ":::\n",
        "\n",
        "## 牛顿（Newton）型\n",
        "\n",
        "**构造思路**：逐点“增量”扩展。设\n",
        "$$\n",
        "p_k(x)=c_0 + c_1(x-x_0)+\\cdots+c_k\\prod_{j=0}^{k-1}(x-x_j).\n",
        "$$\n",
        "\n",
        "令 $p_k$ 同时通过 $x_0,\\dots,x_k$。当新增 $x_k$ 时，\n",
        "$$\n",
        "p_k(x_k)-p_{k-1}(x_k)=c_k\\prod_{j=0}^{k-1}(x_k-x_j).\n",
        "$$\n",
        "\n",
        "左边等于 $y_k-p_{k-1}(x_k)$。故\n",
        "$$\n",
        "c_k=\\frac{y_k-p_{k-1}(x_k)}{\\prod_{j=0}^{k-1}(x_k-x_j)}.\n",
        "$$\n",
        "\n",
        "把右端写成**差商**（divided differences）记号，得到递推表：\n",
        "$$\n",
        "c_0=f[x_0]=y_0,\\quad\n",
        "c_1=f[x_0,x_1]=\\frac{y_1-y_0}{x_1-x_0},\\quad\n",
        "c_2=f[x_0,x_1,x_2]=\\frac{f[x_1,x_2]-f[x_0,x_1]}{x_2-x_0},\\ \\dots\n",
        "$$\n",
        "\n",
        "最终\n",
        "$$\n",
        "p_n(x)=c_0 + c_1(x-x_0)+ c_2(x-x_0)(x-x_1)+\\cdots + c_n\\prod_{j=0}^{n-1}(x-x_j)=\\sum_{k=0}^{n} f[x_0,\\dots,x_k]\\;\\prod_{j=0}^{k-1}(x-x_j),\n",
        "$$\n",
        "\n",
        "其中 $c_k=f[x_0,\\dots,x_k]$。\n",
        "\n",
        "并可用**Horner 样式**自右向左嵌套求值，复杂度 $O(n)$。\n",
        "\n",
        "::: callout-note\n",
        "秦九韶-霍纳（Horner）方法是一种通过将多项式重写为一系列嵌套的线性表达式来高效地求出给定值处多项式值的算法。\n",
        ":::\n",
        "\n",
        "### 差商表\n",
        "\n",
        "| $x_i$ | $f[x_i]=y_i$ | $f[x_i,x_{i+1}]=\\frac{f[x_{i+1}]-f[x_i]}{x_{i+1}-x_i}$ | $f[x_i,x_{i+1},x_{i+2}]=\\frac{f[x_{i+1},x_{i+2}]-f[x_i,x_{i+1}]}{x_{i+2}-x_i}$ | $f[x_i,\\dots,x_{i+k}]=\\frac{f[x_{i+1},\\dots,x_{i+k}]-f[x_i,\\dots,x_{i+k-1}]}{x_{i+k}-x_i}$ |\n",
        "|-------|--------------|--------------------------------------------------------|---------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------|\n",
        "| $x_0$ | $y_0$ | | | |\n",
        "| $x_1$ | $y_1$ | $f[x_0,x_1]$ | | |\n",
        "| $x_2$ | $y_2$ | $f[x_1,x_2]$ | $f[x_0,x_1,x_2]$ | |\n",
        "| $x_3$ | $y_3$ | $f[x_2,x_3]$ | $f[x_1,x_2,x_3]$ | $f[x_0,x_1,x_2,x_3]$ |\n",
        "| $\\vdots$ | $\\vdots$ | $\\vdots$ | $\\vdots$ | $\\ddots$ |\n",
        "\n",
        "示例：假设我们有一组数据点 $(0, 1)$, $(1, 3)$, $(2, 2)$, $(4, 5)$\n",
        "\n",
        "| $x_i$ | $f[x_i]$ | $f[x_i,x_{i+1}]$ | $f[x_i,x_{i+1},x_{i+2}]$ | $f[x_i,x_{i+1},x_{i+2},x_{i+3}]$ |\n",
        "|-------|----------|------------------|--------------------------|----------------------------------|\n",
        "| 0 | 1 | | | |\n",
        "| 1 | 3 | $\\frac{3-1}{1-0}=2$ | | |\n",
        "| 2 | 2 | $\\frac{2-3}{2-1}=-1$ | $\\frac{-1-2}{2-0}=-\\frac{3}{2}$ | |\n",
        "| 4 | 5 | $\\frac{5-2}{4-2}=\\frac{3}{2}$ | $\\frac{\\frac{3}{2}-(-1)}{4-1}=\\frac{5}{6}$ | $\\frac{\\frac{5}{6}-(-\\frac{3}{2})}{4-0}=\\frac{7}{12}$ |\n",
        "\n",
        "对角线元素（每行右上角的条目）是牛顿除差插值公式中使用的系数。\n",
        "\n",
        "::: callout-note\n",
        "增量更新方便，添加新节点仅多一列差商。\n",
        ":::\n",
        "\n",
        "### 牛顿法的实现"
      ],
      "id": "f83a4d91"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "def divided_differences(x_nodes, y_nodes):\n",
        "    x = np.asarray(x_nodes, dtype=np.float64)\n",
        "    coef = np.asarray(y_nodes, dtype=np.float64).copy()\n",
        "    n = len(x)\n",
        "    for k in range(1, n):\n",
        "        coef[k:n] = (coef[k:n] - coef[k-1:n-1]) / (x[k:n] - x[:n-k])\n",
        "    return coef  # c0..c_{n-1}\n",
        "\n",
        "def newton_eval(x_nodes, coef, x):\n",
        "    x_nodes = np.asarray(x_nodes, dtype=np.float64)\n",
        "    coef = np.asarray(coef, dtype=np.float64)\n",
        "    x = np.atleast_1d(np.asarray(x, dtype=np.float64))\n",
        "    n = len(coef)\n",
        "    p = np.zeros_like(x) + coef[-1]\n",
        "    for k in range(n-2, -1, -1):\n",
        "        p = coef[k] + (x - x_nodes[k]) * p\n",
        "    return p if p.ndim else p.item()"
      ],
      "id": "22550a92",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 重心公式推导\n",
        "从拉格朗日型起步。把 $\\ell_i(x)$ 重写为\n",
        "\n",
        "$$\n",
        "\\ell_i(x)=\\frac{\\displaystyle\\prod_{j\\ne i}(x-x_j)}{\\displaystyle\\prod_{j\\ne i}(x_i-x_j)}\n",
        "=\\frac{\\displaystyle\\prod_{j=0}^{n}(x-x_j)}{x-x_i}\\cdot\n",
        "\\underbrace{\\frac{1}{\\displaystyle\\prod_{j\\ne i}(x_i-x_j)}}_{w_i}\n",
        "$$\n",
        "\n",
        "记 $w_i:=\\bigl(\\prod_{j\\ne i}(x_i-x_j)\\bigr)^{-1}$。于是\n",
        "$$\n",
        "p_n(x)=\\sum_{i=0}^{n} y_i\\,\\ell_i(x)\n",
        "=\\Bigl(\\prod_{j=0}^{n}(x-x_j)\\Bigr)\\sum_{i=0}^{n}\\frac{w_i\\,y_i}{x-x_i}\n",
        "$$\n",
        "\n",
        "注意到 $\\sum_{i}\\ell_i(x)\\equiv 1$ 同理可得\n",
        "$$\n",
        "1=\\Bigl(\\prod_{j=0}^{n}(x-x_j)\\Bigr)\\sum_{i=0}^{n}\\frac{w_i}{x-x_i}.\n",
        "$$\n",
        "\n",
        "两式相除，得到**重心（barycentric）公式**：\n",
        "$$\n",
        "\\boxed{\\,p_n(x)=\\frac{\\displaystyle \\sum_{i=0}^n \\frac{w_i\\,y_i}{x-x_i}}\n",
        "{\\displaystyle \\sum_{i=0}^n \\frac{w_i}{x-x_i}}\\,}.\n",
        "$$\n",
        "\n",
        "若 $x=x_k$ 时，分子分母同时出现奇点，但极限为 $y_k$，实现上**直接返回 $y_k$** 即可。\n",
        "\n",
        "## 重心插值的数值稳定性\n",
        "\n",
        "* **第一重心公式**：\n",
        "\n",
        "  $$\n",
        "  p_n(x)=\\frac{\\sum_{i=0}^n \\displaystyle \\frac{w_i\\,y_i}{x-x_i}}\n",
        "               {\\sum_{i=0}^n \\displaystyle \\frac{w_i}{x-x_i}},\\qquad\n",
        "  w_i=\\frac{1}{\\prod_{j\\ne i}(x_i-x_j)}\n",
        "  $$\n",
        "\n",
        "* **第二重心公式**：对某些节点（如切比雪夫）选择**简洁权重**，数值更稳定。\n",
        "* **要点**：\n",
        "\n",
        "  * 若 $x$ 恰好等于某个 $x_k$，直接返回 $y_k$（避免 `0/0`）。\n",
        "  * 预计算权重 $w_i$ 的**代价 $O(n^2)$**，单点求值 $O(n)$。\n",
        "\n",
        "### 重心法的实现"
      ],
      "id": "eee188a3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "def barycentric_weights(x_nodes):\n",
        "    x = np.asarray(x_nodes, dtype=np.float64)\n",
        "    n = len(x)\n",
        "    w = np.ones(n, dtype=np.float64)\n",
        "    for j in range(n):\n",
        "        w[j] = 1.0/np.prod(x[j] - np.delete(x, j))\n",
        "    return w\n",
        "\n",
        "def barycentric_eval(x_nodes, y_nodes, x, w=None):\n",
        "    x_nodes = np.asarray(x_nodes, dtype=np.float64)\n",
        "    y_nodes = np.asarray(y_nodes, dtype=np.float64)\n",
        "    if w is None:\n",
        "        w = barycentric_weights(x_nodes)\n",
        "    w = np.asarray(w, dtype=np.float64)\n",
        "    x = np.atleast_1d(np.asarray(x, dtype=np.float64))\n",
        "\n",
        "    out = np.empty_like(x)\n",
        "    for k, xv in enumerate(x):\n",
        "        diff = xv - x_nodes\n",
        "        idx = np.where(diff == 0)[0]\n",
        "        if len(idx) > 0:\n",
        "            out[k] = y_nodes[idx[0]]\n",
        "        else:\n",
        "            num = np.sum(w * y_nodes / diff)\n",
        "            den = np.sum(w / diff)\n",
        "            out[k] = num/den\n",
        "    return out if out.ndim else out.item()"
      ],
      "id": "e0a5f132",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 方法对比\n",
        "\n",
        "**示例数据**\n",
        "\n",
        "电池开路电压 **OCV** 与荷电状态 **SoC** 的标定曲线。\n",
        " \n",
        "- 自变量：$\\text{SoC}\\in[0,1]$  \n",
        "- 因变量：$\\text{OCV}$（单位：V）  \n",
        "- 特征：整体单调、在中段略 S 形，适合用来测试插值与样条。\n",
        "\n",
        "**数据表**\n",
        "\n",
        "| idx | SoC $x_i$ | OCV $y_i$ (V) |\n",
        "|---:|:-----------:|:----------------:|\n",
        "| 0  | 0.00 | 3.000 |\n",
        "| 1  | 0.10 | 3.130 |\n",
        "| 2  | 0.20 | 3.255 |\n",
        "| 3  | 0.30 | 3.380 |\n",
        "| 4  | 0.40 | 3.505 |\n",
        "| 5  | 0.50 | 3.635 |\n",
        "| 6  | 0.60 | 3.780 |\n",
        "| 7  | 0.70 | 3.935 |\n",
        "| 8  | 0.80 | 4.075 |\n",
        "| 9  | 0.90 | 4.170 |\n",
        "| 10 | 1.00 | 4.240 |\n",
        "\n",
        "### 代码：载入数据并用三种插值法对比"
      ],
      "id": "79d5fe7f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "plt.rcParams[\"font.sans-serif\"] = [\"PingFang SC\", \"Arial Unicode MS\"]\n",
        "plt.rcParams[\"axes.unicode_minus\"] = False\n",
        "\n",
        "# 节点\n",
        "x_nodes = np.linspace(0.0, 1.0, 11, dtype=np.float64)\n",
        "y_nodes = np.array(\n",
        "    [3.000, 3.130, 3.255, 3.380, 3.505, 3.635, 3.780, 3.935, 4.075, 4.170, 4.240],\n",
        "    dtype=np.float64,\n",
        ")\n",
        "\n",
        "# 求值点\n",
        "xs = np.linspace(0, 1, 801, dtype=np.float64)\n",
        "\n",
        "\n",
        "# 计算\n",
        "w = barycentric_weights(x_nodes)\n",
        "y_bary = barycentric_eval(x_nodes, y_nodes, xs, w)\n",
        "coef = divided_differences(x_nodes, y_nodes)\n",
        "y_newt = newton_eval(x_nodes, coef, xs)\n",
        "y_lagr = lagrange_eval(x_nodes, y_nodes, xs)\n",
        "\n",
        "plt.figure(figsize=(6, 4))\n",
        "plt.plot(xs, y_bary, \"-\", label=\"Barycentric\")\n",
        "plt.plot(xs, y_newt, \"--\", label=\"Newton (Horner)\")\n",
        "plt.plot(xs, y_lagr, \":\", label=\"Lagrange (direct)\")\n",
        "plt.plot(x_nodes, y_nodes, \"o\", label=\"nodes\")\n",
        "plt.xlabel(\"SoC\")\n",
        "plt.ylabel(\"OCV (V)\")\n",
        "plt.title(\"示例数据的三种插值对比\")\n",
        "plt.grid(True, alpha=0.3)\n",
        "plt.legend()\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "40f74ffa",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 节点选择\n",
        "\n",
        "- **等距节点**在区间端点附近“太稀疏”，导致插值基函数幅度巨大，插值误差与数值误差都被严重放大，这在高阶时表现为 **Runge 现象**，即端点振荡。\n",
        "- **切比雪夫（Chebyshev）节点**把点密集地“压”在两端（$[-1,1]$ 上的密度 $\\rho(x)=\\dfrac{1}{\\pi\\sqrt{1-x^2}}$），能显著降低最大插值误差与**Lebesgue 常数** $\\Lambda_n$ 的增长速度，约为对数级。\n",
        "\n",
        "\n",
        "### Chebyshev 插值节点\n",
        "\n",
        "- **Chebyshev 多项式**  \n",
        "\n",
        "  1) 一类 $T_k(x)=\\cos(k\\arccos x)$；\n",
        "  2) 二类 $U_k(x)=\\dfrac{\\sin((k+1)\\arccos x)}{\\sin(\\arccos x)}$。\n",
        "- **两种常用“Chebyshev 插值节点”**都定义在 $[-1,1]$：\n",
        "  1) **一类节点不含端点**  \n",
        "     $$\n",
        "     x_j=\\cos\\frac{(2j+1)\\pi}{2(n+1)},\\quad j=0,\\dots,n.\n",
        "     $$\n",
        "     它们是 $T_{n+1}(x)$ 的**零点**，常见于“Gauss 型”设置（不含端点）。\n",
        "  2) **二类节点含端点**  \n",
        "     $$\n",
        "     x_j=\\cos\\frac{j\\pi}{n},\\quad j=0,\\dots,n.\n",
        "     $$\n",
        "\n",
        "     这些是 $T_n(x)$ 的**极值点**（端点 $\\pm1$ 含在内），又常被称为**Chebyshev–Lobatto** 节点。\n",
        "\n",
        "::: callout-tip\n",
        "**工程建议**：做全局多项式插值时，**优先用二类节点**，便于与边界条件衔接；若确需避开端点，可用一类节点。\n",
        ":::\n",
        "\n",
        "\n",
        "### 切比雪夫节点性质\n",
        "1) **$\\omega_{n+1}$ 振幅最小化**  \n",
        "   在 $[-1,1]$ 上，取“一类切比雪夫零点”时，有  \n",
        "   $$\n",
        "   \\omega_{n+1}(x)=\\prod_{j=0}^{n}(x-x_j)=2^{-n}T_{n+1}(x),\n",
        "   $$\n",
        "\n",
        "   而 $|T_{n+1}(x)|\\le 1$。这解释了为何端点不会出现如等距那样的爆炸振荡。\n",
        "2) **Lebesgue 常数 $\\Lambda_n$ 仅对数增长**  \n",
        "   对切比雪夫节点，$\\Lambda_n\\sim \\tfrac{2}{\\pi}\\log n + O(1)$；等距节点的 $\\Lambda_n$ 增长更快，常常“失控”，引发振荡。\n",
        "\n",
        "## 误差与 Lebesgue 常数\n",
        "\n",
        "我们知道，插值误差可写为\n",
        "\n",
        "  $$\n",
        "  f(x)-p_n(x) = \\frac{f^{(n+1)}(\\xi_x)}{(n+1)!}\\,\\omega_{n+1}(x),\n",
        "  $$\n",
        "\n",
        "\n",
        "但实际数值误差还放大为 **Lebesgue 常数** $\\Lambda_n$：\n",
        "\n",
        "  $$\n",
        "  \\|f-p_n\\|_\\infty \\le (1+\\Lambda_n)\\inf_{q\\in\\Pi_n}\\|f-q\\|_\\infty.\n",
        "  $$\n",
        "\n",
        "::: callout-tip\n",
        "工程建议：优先选切比雪夫（或其仿射）节点。\n",
        ":::\n",
        "\n",
        "\n",
        "### 区间映射\n",
        "\n",
        "从 $[-1,1]$ 到任意 $[a,b]$ 的映射采用如下方法：\n",
        "$$\n",
        "x_j^{[a,b]}=\\frac{a+b}{2}+\\frac{b-a}{2}\\,x_j^{[-1,1]},\n",
        "$$\n",
        "\n",
        "其中 $x_j^{[-1,1]}$ 取一类或二类切比雪夫节点即可。\n",
        "\n",
        "\n",
        "### 第二重心公式实现要点\n",
        "二类节点的**闭式权重**，幅度有界、交替符号：\n",
        "$$\n",
        "  w_j=\n",
        "  \\begin{cases}\n",
        "  \\tfrac12(-1)^j, & j=0\\ \\text{或}\\ j=n,\\\\\n",
        "  (-1)^j, & \\text{否则}.\n",
        "  \\end{cases}\n",
        "$$\n",
        "\n",
        "用它代入重心公式\n",
        "$$\n",
        "  p_n(x)=\\frac{\\sum\\limits_{j=0}^n \\dfrac{w_j\\,y_j}{x-x_j}}\n",
        "               {\\sum\\limits_{j=0}^n \\dfrac{w_j}{x-x_j}},\n",
        "$$\n",
        "\n",
        "**更具数值稳定性**，且无需再做 $O(n^2)$ 的通用权重预处理。\n",
        "\n",
        "- 一类节点的闭式权重也很简洁：$w_j = (-1)^j$，所有点同模长。  \n",
        "- 若 $x$ 与某个 $x_k$**恰好相等**，直接返回 $y_k$（避免 `0/0`）。批量求值时可先做相等掩码。\n",
        "\n",
        "\n",
        "### 比较实验\n",
        "\n",
        "比较等距节点与切比雪夫二类节点的节点密度与勒贝格（Lebesgue）函数"
      ],
      "id": "9d612dba"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | code-fold: true\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "\n",
        "def nodes_equidistant(a, b, n):\n",
        "    j = np.arange(n + 1, dtype=np.float64)\n",
        "    return a + (b - a) * j / n\n",
        "\n",
        "\n",
        "def nodes_chebyshev_lobatto(a, b, n):\n",
        "    j = np.arange(n + 1, dtype=np.float64)\n",
        "    xi = np.cos(np.pi * j / n)  # [-1,1]\n",
        "    return (a + b) / 2 + (b - a) / 2 * xi\n",
        "\n",
        "\n",
        "def lebesgue_function(x_nodes, x_eval):\n",
        "    \"\"\"用重心基函数稳定计算勒贝格函数 Λ_n(x)=sum_i |ℓ_i(x)|.\"\"\"\n",
        "    x = np.asarray(x_nodes, dtype=np.float64)\n",
        "    xe = np.asarray(x_eval, dtype=np.float64)\n",
        "    n = len(x) - 1\n",
        "    # 选“Lobatto”闭式权重；若改用等距节点，可退回通用权重（O(n^2)）\n",
        "    # 这里为了公平比较而统一用通用权重\n",
        "    w = np.ones_like(x)\n",
        "    for j in range(n + 1):\n",
        "        w[j] = 1.0 / np.prod(x[j] - np.delete(x, j))\n",
        "\n",
        "    L = np.empty_like(xe)\n",
        "    for k, xv in enumerate(xe):\n",
        "        diff = xv - x\n",
        "        if np.any(diff == 0):\n",
        "            L[k] = 1.0  # 在节点处 ℓ_k=1 其余为 0，Lebesgue 函数取 1\n",
        "        else:\n",
        "            denom = np.sum(w / diff)\n",
        "            phi = (w / diff) / denom  # 重心下的 ℓ_i(x)\n",
        "            L[k] = np.sum(np.abs(phi))  # Lebesgue 函数\n",
        "    return L\n",
        "\n",
        "\n",
        "n = 16\n",
        "xeq = nodes_equidistant(-1, 1, n)\n",
        "xch = nodes_chebyshev_lobatto(-1, 1, n)\n",
        "xx = np.linspace(-1, 1, 2001)\n",
        "\n",
        "L_eq = lebesgue_function(xeq, xx)\n",
        "L_ch = lebesgue_function(xch, xx)\n",
        "\n",
        "fig, ax = plt.subplots(2, 1, figsize=(6, 7))\n",
        "# 节点分布\n",
        "ax[0].plot(xeq, 0 * xeq, \"o\", label=\"等距\")\n",
        "ax[0].plot(xch, 0 * xch + 0.05, \"x\", label=\"切比雪夫\")\n",
        "ax[0].set_title(\"节点分布\")\n",
        "ax[0].set_yticks([])\n",
        "ax[0].grid(True, alpha=0.3)\n",
        "ax[0].legend()\n",
        "\n",
        "# Lebesgue 函数\n",
        "ax[1].plot(xx, L_eq, label=\"等距 Lebesgue\")\n",
        "ax[1].plot(xx, L_ch, label=\"切比雪夫 Lebesgue\")\n",
        "ax[1].set_title(\"Lebesgue 函数对比（n=16）\")\n",
        "ax[1].set_xlabel(\"x\")\n",
        "ax[1].set_ylabel(r\"$\\Lambda_n(x)$\")\n",
        "ax[1].grid(True, alpha=0.3)\n",
        "ax[1].legend()\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "1e7d3053",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Runge 现象：示例与对比\n",
        "\n",
        "* 经典函数：\n",
        "\n",
        "  $$\n",
        "  f(x)=\\frac{1}{1+25x^2},\\qquad x\\in[-1,1].\n",
        "  $$\n",
        "\n",
        "\n",
        "### 可视化\n",
        "\n",
        "通过不同阶数、两种节点的插值，观察**等距节点**的高次多项式在区间端点出现巨振荡，而**切比雪夫节点**显著更稳"
      ],
      "id": "6085570f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | code-fold: true\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "plt.rcParams[\"font.sans-serif\"] = [\"PingFang SC\", \"Arial Unicode MS\"]\n",
        "plt.rcParams[\"axes.unicode_minus\"] = False\n",
        "\n",
        "\n",
        "def runge(x):\n",
        "    return 1.0 / (1.0 + 25.0 * x * x)\n",
        "\n",
        "\n",
        "def interp_bary(x_nodes, fvals, x_eval, w=None):\n",
        "    return barycentric_eval(x_nodes, fvals, x_eval, w)\n",
        "\n",
        "\n",
        "def bary_weights_cheb_lobatto(n):\n",
        "    j = np.arange(n + 1)\n",
        "    w = np.where((j == 0) | (j == n), 0.5, 1.0) * ((-1.0) ** j)\n",
        "    return w.astype(np.float64)\n",
        "\n",
        "\n",
        "xs = np.linspace(-1, 1, 2001)\n",
        "orders = [4, 8, 12, 16]\n",
        "\n",
        "fig, axes = plt.subplots(len(orders), 2, figsize=(8, 8), sharex=True, sharey=True)\n",
        "for r, n in enumerate(orders):\n",
        "    # 等距\n",
        "    xe = nodes_equidistant(-1, 1, n)\n",
        "    ye = runge(xe)\n",
        "    ye_hat = interp_bary(xe, ye, xs)  # 通用权重\n",
        "    axes[r, 0].plot(xs, runge(xs), \"k-\", lw=1, label=\"f(x)\")\n",
        "    axes[r, 0].plot(xs, ye_hat, \"-\", lw=1.2, label=f\"poly (n={n})\")\n",
        "    axes[r, 0].plot(xe, ye, \"o\", ms=3)\n",
        "    axes[r, 0].set_title(f\"等距节点 n={n}\")\n",
        "\n",
        "    # 切比雪夫（Lobatto）\n",
        "    xc = nodes_chebyshev_lobatto(-1, 1, n)\n",
        "    yc = runge(xc)\n",
        "    wc = bary_weights_cheb_lobatto(n)\n",
        "    yc_hat = interp_bary(xc, yc, xs, w=wc)  # 重心第二公式权重\n",
        "    axes[r, 1].plot(xs, runge(xs), \"k-\", lw=1, label=\"f(x)\")\n",
        "    axes[r, 1].plot(xs, yc_hat, \"-\", lw=1.2, label=f\"poly (n={n})\")\n",
        "    axes[r, 1].plot(xc, yc, \"o\", ms=3)\n",
        "    axes[r, 1].set_title(f\"切比雪夫节点 n={n}\")\n",
        "\n",
        "for ax in axes.flat:\n",
        "    ax.grid(True, alpha=0.3)\n",
        "axes[-1, 0].set_xlabel(\"x\")\n",
        "axes[-1, 1].set_xlabel(\"x\")\n",
        "axes[0, 0].legend(loc=\"lower center\", ncol=2, fontsize=9)\n",
        "fig.suptitle(\"Runge 现象\", y=0.99)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "671ca163",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 分段插值\n",
        "\n",
        "全局高次多项式在端点易发散，为了**缓解 Runge 振荡**，可以选择在每个小区间内仅用三次多项式，整体 $C^2$ 光滑，稳定边界。这是一种**分段插值**。\n",
        "\n",
        "用分段插值更新方便，**只改动一小段数据**，影响局限在邻近区间。而全局多项式会“牵一发而动全身”。\n",
        "\n",
        "当节点较多、需要稳定可控的全区间插值时，分段**三次样条**（cubic spline）是更好的默认选择。\n",
        "\n",
        "## 三次样条插值\n",
        "\n",
        "给定严格单调的节点\n",
        "$$\n",
        "x_0<x_1<\\cdots<x_n,\\qquad y_i=f(x_i),\n",
        "$$\n",
        "\n",
        "在每个区间 $[x_i,x_{i+1}]$ 上构造三次多项式 $S_i(x)$，拼接成\n",
        "$$\n",
        "S(x)=S_i(x),\\quad x\\in[x_i,x_{i+1}],\n",
        "$$\n",
        "\n",
        "使得：\n",
        "\n",
        "1) **插值条件**：$S(x_i)=y_i$（全体端点匹配）；  \n",
        "2) **一阶连续**：$S_i'(x_{i+1})=S_{i+1}'(x_{i+1})$（所有内节点光滑）；  \n",
        "3) **二阶连续**：$S_i''(x_{i+1})=S_{i+1}''(x_{i+1})$（曲率连续）；  \n",
        "4) **自然边界**：$S''(x_0)=S''(x_n)=0$。\n",
        "\n",
        "记\n",
        "$$\n",
        "h_i:=x_{i+1}-x_i>0,\\qquad m_i:=S''(x_i),\\quad i=0,\\dots,n.\n",
        "$$\n",
        "\n",
        "在每个区间 $[x_i,x_{i+1}]$ 上，三次多项式的二阶导 $S_i''$ 是**一次函数**。用端点值线性插值：\n",
        "$$\n",
        "S_i''(x)=(1-t)\\,m_i+t\\,m_{i+1},\\qquad t:=\\frac{x-x_i}{h_i}\\in[0,1].\n",
        "$$\n",
        "\n",
        "对 $x$ 积分一次得一阶导，积分常数记为 $A_i$：\n",
        "$$\n",
        "\\begin{aligned}\n",
        "S_i'(x)\n",
        "&=\\int S_i''(x)\\,dx\n",
        "= \\int\\Bigl(m_i + (m_{i+1}-m_i)\\frac{x-x_i}{h_i}\\Bigr)\\,dx + A_i \\\\\n",
        "&= m_i(x-x_i)+\\frac{m_{i+1}-m_i}{2h_i}(x-x_i)^2 + A_i.\n",
        "\\end{aligned}\n",
        "$$\n",
        "\n",
        "再积分一次得 $S_i(x)$（积分常数记为 $B_i$）：\n",
        "$$\n",
        "S_i(x)\n",
        "= \\frac{m_i}{2}(x-x_i)^2 + \\frac{m_{i+1}-m_i}{6h_i}(x-x_i)^3 + A_i(x-x_i)+B_i.\n",
        "$$\n",
        "\n",
        "用**端点插值条件**确定 $A_i,B_i$：\n",
        "\n",
        "- 令 $x=x_i$，得 $S_i(x_i)=B_i=y_i\\Rightarrow B_i=y_i$；\n",
        "- 令 $x=x_{i+1}\\Rightarrow x-x_i=h_i$，代入得到\n",
        "  $$\n",
        "  y_{i+1}\n",
        "  = \\frac{m_i}{2}h_i^2 + \\frac{m_{i+1}-m_i}{6h_i}h_i^3 + A_i h_i + y_i\n",
        "  = y_i + \\frac{h_i^2}{6}(2m_i+m_{i+1}) + A_i h_i,\n",
        "  $$\n",
        "\n",
        "  从而\n",
        "  $$\n",
        "  A_i=\\frac{y_{i+1}-y_i}{h_i} - \\frac{h_i}{6}(2m_i+m_{i+1}).\n",
        "  $$\n",
        "\n",
        "把 $A_i,B_i$ 代回 $S_i(x)$，并把 $(x-x_i)$、$(x_{i+1}-x)$ 对称化，可得**经典样条显式式**：\n",
        "$$\n",
        "\\boxed{\\\n",
        "\\begin{aligned}\n",
        "S_i(x)\n",
        "&= \\frac{m_i\\,(x_{i+1}-x)^3}{6h_i}\n",
        " + \\frac{m_{i+1}\\,(x-x_i)^3}{6h_i} \\\\\n",
        "&\\quad + \\Bigl(y_i-\\frac{m_i h_i^2}{6}\\Bigr)\\frac{x_{i+1}-x}{h_i}\n",
        " + \\Bigl(y_{i+1}-\\frac{m_{i+1} h_i^2}{6}\\Bigr)\\frac{x-x_i}{h_i},\n",
        "\\qquad x\\in[x_i,x_{i+1}].\n",
        "\\end{aligned}}\n",
        "$$\n",
        "\n",
        "该式表明：**只要知道 $m_i$ 序列，就能对整条样条求值**。\n",
        "\n",
        "## 建立三对角方程\n",
        "\n",
        "由上式求两端一阶导（$x\\to x_i^+$ 与 $x\\to x_{i+1}^-$）：\n",
        "$$\n",
        "\\begin{aligned}\n",
        "S_i'(x_i^+) &= \\frac{y_{i+1}-y_i}{h_i} - \\frac{h_i}{6}(2m_i+m_{i+1}),\\\\\n",
        "S_i'(x_{i+1}^-) &= \\frac{y_{i+1}-y_i}{h_i} + \\frac{h_i}{6}(m_i+2m_{i+1}).\n",
        "\\end{aligned}\n",
        "$$\n",
        "\n",
        "对内节点 $x_i$（$i=1,\\dots,n-1$）应用**一阶连续性**条件：\n",
        "$$\n",
        "S_{i-1}'(x_i^-)=S_i'(x_i^+).\n",
        "$$\n",
        "\n",
        "把上式两端点导数代入并整理，得到关于 $\\{m_i\\}$ 的**三对角线性系统**：\n",
        "$$\n",
        "\\boxed{\\\n",
        "h_{i-1} m_{i-1} + 2(h_{i-1}+h_i) m_i + h_i m_{i+1}\n",
        "= 6\\!\\left(\\frac{y_{i+1}-y_i}{h_i} - \\frac{y_i-y_{i-1}}{h_{i-1}}\\right),\n",
        "\\quad i=1,\\dots,n-1.}\n",
        "$$\n",
        "\n",
        "再配上**自然边界** $m_0=0,\\ m_n=0$，即可唯一解出 $m$。\n",
        "\n",
        "::: callout-note\n",
        "三对角矩阵对称、其内部行严格对角占优，因此可用 **Thomas 算法**（追赶法）在线性时间 $O(n)$ 稳定求解。\n",
        ":::\n",
        "\n",
        "\n",
        "### 求解 $m$"
      ],
      "id": "8729112b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | code-fold: true\n",
        "import numpy as np\n",
        "\n",
        "\n",
        "def natural_cubic_spline(x_nodes, y_nodes):\n",
        "    x = np.asarray(x_nodes, dtype=np.float64)\n",
        "    y = np.asarray(y_nodes, dtype=np.float64)\n",
        "    n = len(x) - 1\n",
        "    h = np.diff(x)  # h_i = x_{i+1}-x_i\n",
        "    assert np.all(h > 0), \"x_nodes must be strictly increasing\"\n",
        "\n",
        "    # 组装三对角矩阵 A 与右端 b，用于解 m=S''(x_i)\n",
        "    A = np.zeros((n + 1, n + 1), dtype=np.float64)\n",
        "    b = np.zeros(n + 1, dtype=np.float64)\n",
        "\n",
        "    # 自然边界\n",
        "    A[0, 0] = 1.0\n",
        "    A[n, n] = 1.0\n",
        "    b[0] = 0.0\n",
        "    b[n] = 0.0\n",
        "\n",
        "    # 内点方程\n",
        "    for i in range(1, n):\n",
        "        A[i, i - 1] = h[i - 1]\n",
        "        A[i, i] = 2.0 * (h[i - 1] + h[i])\n",
        "        A[i, i + 1] = h[i]\n",
        "        b[i] = 6.0 * ((y[i + 1] - y[i]) / h[i] - (y[i] - y[i - 1]) / h[i - 1])\n",
        "\n",
        "    m = np.linalg.solve(A, b)  # m_0..m_n\n",
        "    return (x, y, m)\n",
        "\n",
        "\n",
        "def spline_eval(spline, x_eval):\n",
        "    x, y, m = spline\n",
        "    x_eval = np.atleast_1d(np.asarray(x_eval, dtype=np.float64))\n",
        "    n = len(x) - 1\n",
        "    # 每个 x 属于哪个区间：x_i <= x < x_{i+1}（最后一个点归到 n-1）\n",
        "    idx = np.clip(np.searchsorted(x, x_eval) - 1, 0, n - 1)\n",
        "    xi, xi1 = x[idx], x[idx + 1]\n",
        "    hi = xi1 - xi\n",
        "    # 三次样条分段公式（标准 Hermite 形式的等价写法）\n",
        "    t = (x_eval - xi) / hi\n",
        "    # 基函数\n",
        "    a = 1 - t\n",
        "    b = t\n",
        "    # 样条插值值：S = a*y_i + b*y_{i+1} + ((a^3 - a)*m_i + (b^3 - b)*m_{i+1}) * (hi^2/6)\n",
        "    S = (\n",
        "        a * y[idx]\n",
        "        + b * y[idx + 1]\n",
        "        + ((a**3 - a) * m[idx] + (b**3 - b) * m[idx + 1]) * (hi**2) / 6.0\n",
        "    )\n",
        "    return S if S.ndim else S.item()"
      ],
      "id": "6b0f5874",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 三次样条小结与要点\n",
        "\n",
        "- **两步法**：\n",
        "\n",
        "  1) 解三对角系统得 $m$；\n",
        "  2) 在任意 $x$ 上用显式方法求值 $S(x)$。  \n",
        "- **数值稳定**：仅解一个条件良好的三对角系统；求值时只做常数次算术运算。  \n",
        "- 可以用下面的边界条件等价地替换上文自然边界的第一行或最后一行：  \n",
        "  - **Clamped 边界，端点给定一阶导**：用 $S'(x_0)=y'_0$、$S'(x_n)=y'_n$ 取代 $m_0=0,m_n=0$；  \n",
        "  - **Not-a-knot 边界**：要求 $x_1$ 与 $x_{n-1}$ 处三次多项式连续到三阶，是软件库的常用默认方法；  \n",
        "  - **周期（periodic）边界**：$S^{(k)}(x_0)=S^{(k)}(x_n)$（$k=0,1,2$）。\n",
        "- **与全局多项式对比**：样条是**分段低次、全局 $C^2$**；在节点多或等距时能显著缓解 Runge 振荡，且具有**局部性**。\n",
        "\n",
        "\n",
        "### 样条 vs 多项式插值：数值对比"
      ],
      "id": "774c742b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# 示例函数（可与 Runge 一致）\n",
        "f = lambda x: 1.0/(1.0 + 25.0*x*x)\n",
        "\n",
        "# 节点较多时：样条平滑稳定；高次多项式在等距点会抖\n",
        "n = 20\n",
        "xe = nodes_equidistant(-1, 1, n)\n",
        "ye = f(xe)\n",
        "\n",
        "# 多项式（重心）\n",
        "ye_hat = barycentric_eval(xe, ye, xs)\n",
        "\n",
        "# 样条\n",
        "spline = natural_cubic_spline(xe, ye)\n",
        "ys_hat = spline_eval(spline, xs)\n",
        "\n",
        "plt.figure(figsize=(7,4))\n",
        "plt.plot(xs, f(xs), 'k-', lw=1, label='f(x)')\n",
        "plt.plot(xs, ye_hat, '-', lw=1.2, label=f'poly (n={n})')\n",
        "plt.plot(xs, ys_hat, '-', lw=1.2, label=f'natural cubic spline ({n+1} nodes)')\n",
        "plt.plot(xe, ye, 'o', ms=3, label='nodes')\n",
        "plt.grid(True, alpha=0.3)\n",
        "plt.legend()\n",
        "plt.title(\"样条 vs 多项式插值（等距节点）\")\n",
        "plt.xlabel(\"x\"); plt.ylabel(\"y\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "e35e4ecf",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 复杂度与工程选择\n",
        "\n",
        "* **牛顿差商**：预处理 $O(n^2)$，单点求值 $O(n)$，易增量更新，稳定性中等。\n",
        "* **重心**：权重预处理 $O(n^2)$（切比雪夫权重则是 $O(n)$ 可直接给出），单点求值 $O(n)$，**稳定性最好**。\n",
        "* **自然三次样条**：一次三对角求解 $O(n)$，对每点 $O(1)$求值，含二分查找 $O(\\log n)$。\n",
        "* 工程实践上：\n",
        "\n",
        "  * 全局光滑且节点适中 → 重心 + 切比雪夫节点\n",
        "  * 节点较多/非均匀/需要局部可控 → 样条插值\n",
        "  * 需要在线追加节点 → 牛顿差商便于维护\n",
        "\n",
        "\n",
        "## 附：勒贝格函数与勒贝格常数\n",
        "\n",
        "**插值算子视角**\n",
        "\n",
        "给定插值节点 $x_0,\\dots,x_n$，把“从样本值 $\\{y_i\\}$ 生成插值多项式 $p_n$”看成一个**线性算子** $I_n$。  \n",
        "对任意 $x$，拉格朗日基函数 $\\{\\ell_i(x)\\}$ 满足 $p_n(x)=\\sum_{i=0}^n y_i\\,\\ell_i(x)$。\n",
        "\n",
        "**勒贝格函数（Lebesgue function）**定义为\n",
        "$$\n",
        "\\Lambda_n(x)=\\sum_{i=0}^n |\\ell_i(x)|.\n",
        "$$\n",
        "\n",
        "**勒贝格常数（Lebesgue constant）**是其在区间上的上界：\n",
        "$$\n",
        "\\Lambda_n = \\max_{x\\in[a,b]} \\Lambda_n(x).\n",
        "$$\n",
        "\n",
        "**意义 1：噪声或扰动的放大系数**  \n",
        "若观测存在扰动 $\\tilde y_i = y_i+\\delta_i$，则\n",
        "$$\n",
        "|I_n(\\tilde y)(x)-I_n(y)(x)|\n",
        "= \\Bigl|\\sum_{i=0}^n \\delta_i\\,\\ell_i(x)\\Bigr|\n",
        "\\le \\Lambda_n(x)\\,\\max_i |\\delta_i|.\n",
        "$$\n",
        "\n",
        "因此 $\\Lambda_n$ 描述了**样本扰动被插值放大**的最坏情况。\n",
        "\n",
        "**意义 2：插值误差的上界**  \n",
        "对任意至多 $n$ 次多项式 $q$，有 $I_n(q)=q$。于是对一般 $f$：\n",
        "$$\n",
        "\\begin{aligned}\n",
        "|f(x)-p_n(x)|\n",
        "&= |f(x)-q(x)+I_n(q)(x)-I_n(f)(x)| \\\\\n",
        "&\\le |f(x)-q(x)| + \\Lambda_n(x)\\,\\|f-q\\|_\\infty.\n",
        "\\end{aligned}\n",
        "$$\n",
        "\n",
        "取区间上最大并对 $q$ 最优（最佳一致逼近多项式），得到常见上界：\n",
        "$$\n",
        "\\|f-p_n\\|_\\infty \\le (1+\\Lambda_n)\\min_{q\\in\\Pi_n}\\|f-q\\|_\\infty\n",
        "$$\n",
        "\n",
        "**节点选择**（影响 $\\Lambda_n$ 的大小）比盲目“加阶”更关键：\n",
        "\n",
        "- 等距节点的 $\\Lambda_n$ 随 $n$ 增长很快，端点振荡严重 \n",
        "- 切比雪夫类节点的 $\\Lambda_n$ 仅**对数级增长**，显著更稳定\n",
        "\n",
        "> $\\ell_i(x)$ 是“权重”，$\\Lambda_n(x)$ 是**权重绝对值之和**；权重越温和，误差与噪声越不易被放大。\n",
        "\n",
        "## 附：三对角矩阵\n",
        "\n",
        "**样条方程的结构**\n",
        "\n",
        "设 $x_0<\\cdots<x_n$，$h_i=x_{i+1}-x_i>0$，记 $m_i=S''(x_i)$。自然边界给出 $m_0=m_n=0$。内点 $i=1,\\dots,n-1$ 满足\n",
        "$$\n",
        "h_{i-1}\\,m_{i-1} + 2(h_{i-1}+h_i)\\,m_i + h_i\\,m_{i+1}\n",
        "= 6\\Bigl(\\frac{y_{i+1}-y_i}{h_i}-\\frac{y_i-y_{i-1}}{h_{i-1}}\\Bigr).\n",
        "$$\n",
        "\n",
        "对应线性系统的系数矩阵 $A$ 是**三对角**（仅主对角与相邻两条对角线非零）：\n",
        "$$\n",
        "A=\n",
        "\\begin{bmatrix}\n",
        "1 &        &        &        &        \\\\\n",
        "h_0 & 2(h_0{+}h_1) & h_1    &        &        \\\\\n",
        "    & \\ddots & \\ddots & \\ddots &        \\\\\n",
        "    &        & h_{n-2} & 2(h_{n-2}{+}h_{n-1}) & h_{n-1} \\\\\n",
        "    &        &        &        & 1\n",
        "\\end{bmatrix}.\n",
        "$$\n",
        "\n",
        "该矩阵在内部行满足\n",
        "$\\;2(h_{i-1}{+}h_i) > h_{i-1}+h_i\\;$，因此**严格对角占优**，数值稳定且唯一可解。\n",
        " \n",
        "三对角系统可用 **Thomas 算法（追赶法）** 在线性时间 $O(n)$ 求解：  \n",
        "\n",
        "- **前向消元**：仅消去下对角，每行常数次运算  \n",
        "- **回代**：从末行向上回代，同样每行常数次运算  \n",
        "\n",
        "相较于一般稠密 $n{\\times}n$ 系统的 $O(n^3)$ 高斯消元，三对角仅需 $O(n)$。"
      ],
      "id": "c9934e28"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "import numpy as np\n",
        "\n",
        "def solve_tridiag(a, b, c, d):\n",
        "    \"\"\"\n",
        "    解三对角系统：\n",
        "      a_i x_{i-1} + b_i x_i + c_i x_{i+1} = d_i\n",
        "    其中 a[0]=c[-1]=0（或忽略），长度均为 n。\n",
        "    返回 x（长度 n）。\n",
        "    \"\"\"\n",
        "    a = np.asarray(a, dtype=np.float64).copy()\n",
        "    b = np.asarray(b, dtype=np.float64).copy()\n",
        "    c = np.asarray(c, dtype=np.float64).copy()\n",
        "    d = np.asarray(d, dtype=np.float64).copy()\n",
        "    n = len(b)\n",
        "\n",
        "    # 前向消元\n",
        "    for i in range(1, n):\n",
        "        w = a[i] / b[i-1]\n",
        "        b[i] = b[i] - w * c[i-1]\n",
        "        d[i] = d[i] - w * d[i-1]\n",
        "\n",
        "    # 回代\n",
        "    x = np.empty(n, dtype=np.float64)\n",
        "    x[-1] = d[-1] / b[-1]\n",
        "    for i in range(n-2, -1, -1):\n",
        "        x[i] = (d[i] - c[i] * x[i+1]) / b[i]\n",
        "    return x"
      ],
      "id": "5735ec3b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**在自然样条中组装 $(a,b,c,d)$**\n",
        "对内点 $i=1..n-1$：\n",
        "\n",
        "$$\n",
        "a_i=h_{i-1},\\quad b_i=2(h_{i-1}{+}h_i),\\quad c_i=h_i,\\quad\n",
        "d_i=6\\Bigl(\\frac{y_{i+1}-y_i}{h_i}-\\frac{y_i-y_{i-1}}{h_{i-1}}\\Bigr).\n",
        "$$\n",
        "\n",
        "边界 $m_0=m_n=0$ 可直接赋值，不进入求解；或把首末两行设为 $[1]$（上文矩阵形式），对应 $a_0=c_0=a_n=c_n=0$, $b_0=b_n=1$, $d_0=d_n=0$。\n",
        "\n",
        "::: callout-note\n",
        "自然样条的三对角矩阵**对称且严格对角占优**（内部块），因此不需主元选取即可稳定求解。这也是样条在工程中的重要优势之一。\n",
        ":::\n",
        "\n",
        "## 小结\n",
        "\n",
        "* 拉格朗日直观、牛顿可增量、重心稳定是首选。\n",
        "* **节点选择**胜过单纯“加阶数”，切比雪夫节点有效控制端点振荡。\n",
        "* **样条**提供分段低次、全局 $C^2$ 光滑的强大替代方案，工程中更常用\n",
        "\n",
        "## 课后作业\n",
        "\n",
        "### a3-1（必做）：计算与证明：\n",
        "\n",
        "推导牛顿差商递推式与其**对称性**。\n",
        "\n",
        "### a3-2（选做）：编程实现 **Clamped** 三次样条\n",
        "\n",
        "1. 将重心插值封装为**统一的 API**：`fit(x, y, kind=\"bary\"/\"newton\"/\"spline\")` 与 `predict(x_eval)`\n",
        "2. 在 $f(x)=|x|$ 与 $f(x)=\\exp(x)$ 两个函数上比较三种方法的最大误差与时间开销，并给出图表\n",
        "\n",
        "\n",
        "## JAX 附录：对比 NumPy 基准\n",
        "\n",
        "使用函数 $\\displaystyle \\mathrm{sinc}_\\pi(x)=\\frac{\\sin(\\pi x)}{\\pi x}$（在 $x=0$ 处定义为 1）。  \n",
        "\n",
        "- 目的：在同一节点与同一求值网格上，比较 **NumPy** 与 **JAX** 的 **重心插值**效果与性能。同时对比等距节点与第二类切比雪夫节点。\n",
        "- 要点：\n",
        "  - JAX 版本采用**通用权重** $w_i = 1/\\prod_{j\\ne i}(x_i-x_j)$ 的 O($n^2$) 实现；  \n",
        "  - 求值阶段使用 `vmap` 批量化 + `jit` 编译，避免 Python 循环；\n",
        "  - 结果与 NumPy 版在数值上应一致（到浮点 10⁻¹⁴～10⁻¹⁵ 量级）。\n",
        "\n",
        "### 代码：NumPy 版"
      ],
      "id": "ec0e8ab1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import time\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "\n",
        "# 函数：sinc_pi(x) = sin(pi x)/(pi x)\n",
        "def sinc_pi(x: np.ndarray) -> np.ndarray:\n",
        "    x = np.asarray(x, dtype=np.float64)\n",
        "    y = np.empty_like(x)\n",
        "    # 避免 0/0\n",
        "    zero = x == 0\n",
        "    y[zero] = 1.0\n",
        "    nz = ~zero\n",
        "    y[nz] = np.sin(np.pi * x[nz]) / (np.pi * x[nz])\n",
        "    return y\n",
        "\n",
        "\n",
        "# 节点映射到 [-L, L]\n",
        "def nodes_equidistant(a, b, n):\n",
        "    j = np.arange(n + 1, dtype=np.float64)\n",
        "    return a + (b - a) * j / n\n",
        "\n",
        "\n",
        "def nodes_chebyshev_lobatto(a, b, n):\n",
        "    j = np.arange(n + 1, dtype=np.float64)\n",
        "    xi = np.cos(np.pi * j / n)  # in [-1,1]\n",
        "    return (a + b) / 2 + (b - a) / 2 * xi\n",
        "\n",
        "\n",
        "# 重心（NumPy）\n",
        "def barycentric_weights_np(x_nodes):\n",
        "    x = np.asarray(x_nodes, dtype=np.float64)\n",
        "    n = len(x)\n",
        "    w = np.ones(n, dtype=np.float64)\n",
        "    for j in range(n):\n",
        "        w[j] = 1.0 / np.prod(x[j] - np.delete(x, j))\n",
        "    return w\n",
        "\n",
        "\n",
        "def barycentric_eval_np(x_nodes, y_nodes, x, w=None):\n",
        "    x_nodes = np.asarray(x_nodes, dtype=np.float64)\n",
        "    y_nodes = np.asarray(y_nodes, dtype=np.float64)\n",
        "    if w is None:\n",
        "        w = barycentric_weights_np(x_nodes)\n",
        "    w = np.asarray(w, dtype=np.float64)\n",
        "    x = np.atleast_1d(np.asarray(x, dtype=np.float64))\n",
        "\n",
        "    out = np.empty_like(x)\n",
        "    for k, xv in enumerate(x):\n",
        "        diff = xv - x_nodes\n",
        "        idx = np.where(diff == 0)[0]\n",
        "        if len(idx) > 0:\n",
        "            out[k] = y_nodes[idx[0]]\n",
        "        else:\n",
        "            num = np.sum(w * y_nodes / diff)\n",
        "            den = np.sum(w / diff)\n",
        "            out[k] = num / den\n",
        "    return out"
      ],
      "id": "e7934e35",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 代码：JAX 版"
      ],
      "id": "f55c402b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import jax, jax.numpy as jnp\n",
        "\n",
        "jax.config.update(\"jax_enable_x64\", True)\n",
        "\n",
        "\n",
        "# 通用权重（O(n^2)），用广播 + 对角置 1 避免零因子\n",
        "def barycentric_weights_jax(x_nodes):\n",
        "    x = jnp.asarray(x_nodes, dtype=jnp.float64)\n",
        "    n = x.shape[0]\n",
        "    diff = x[:, None] - x[None, :]\n",
        "    diff = diff + jnp.eye(n, dtype=x.dtype)  # 使对角为 1\n",
        "    prod = jnp.prod(diff, axis=1)\n",
        "    w = 1.0 / prod\n",
        "    return w\n",
        "\n",
        "\n",
        "# 单点求值，处理与节点重合\n",
        "def barycentric_eval_one_jax(x_nodes, y_nodes, w, xv):\n",
        "    diff = xv - x_nodes\n",
        "    # 精确相等判断：插值时求值点常与节点完全一致\n",
        "    mask = diff == 0.0\n",
        "\n",
        "    def coincident():\n",
        "        # 返回对应 y_k，若多于一个 True，argmax 取第一个\n",
        "        return y_nodes[jnp.argmax(mask)]\n",
        "\n",
        "    def general():\n",
        "        num = jnp.sum(w * y_nodes / diff)\n",
        "        den = jnp.sum(w / diff)\n",
        "        return num / den\n",
        "\n",
        "    return jax.lax.cond(mask.any(), coincident, general)\n",
        "\n",
        "\n",
        "# 向量化 + JIT\n",
        "def make_bary_eval_many_jax(x_nodes, y_nodes, w):\n",
        "    x_nodes = jnp.asarray(x_nodes, dtype=jnp.float64)\n",
        "    y_nodes = jnp.asarray(y_nodes, dtype=jnp.float64)\n",
        "    w = jnp.asarray(w, dtype=jnp.float64)\n",
        "\n",
        "    def eval_many(x):\n",
        "        x = jnp.asarray(x, dtype=jnp.float64)\n",
        "        return jax.vmap(lambda xv: barycentric_eval_one_jax(x_nodes, y_nodes, w, xv))(x)\n",
        "\n",
        "    return jax.jit(eval_many)"
      ],
      "id": "0c199b07",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 对比实验：NumPy vs JAX"
      ],
      "id": "c8a77113"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "L = 5.0\n",
        "n = 20  # 插值阶数（n+1 个节点）\n",
        "xs = np.linspace(-L, L, 20001, dtype=np.float64)  # 稠密网格\n",
        "fx = sinc_pi(xs)\n",
        "\n",
        "\n",
        "def run_once(x_nodes):\n",
        "    y_nodes = sinc_pi(x_nodes)\n",
        "\n",
        "    # NumPy\n",
        "    w_np = barycentric_weights_np(x_nodes)\n",
        "    t0 = time.perf_counter()\n",
        "    y_np = barycentric_eval_np(x_nodes, y_nodes, xs, w_np)\n",
        "    t1 = time.perf_counter()\n",
        "\n",
        "    out = {\"y_np\": y_np, \"t_np_ms\": (t1 - t0) * 1e3, \"w_np\": w_np, \"y_nodes\": y_nodes}\n",
        "\n",
        "    # JAX\n",
        "    xj = jnp.asarray(x_nodes, dtype=jnp.float64)\n",
        "    yj = jnp.asarray(y_nodes, dtype=jnp.float64)\n",
        "    wj = barycentric_weights_jax(xj)\n",
        "\n",
        "    eval_many = make_bary_eval_many_jax(xj, yj, wj)\n",
        "\n",
        "    # 预热（编译）\n",
        "    _ = np.array(eval_many(jnp.asarray(xs[:8])))\n",
        "\n",
        "    # 计时（已编译态）\n",
        "    t2 = time.perf_counter()\n",
        "    y_jax = np.array(eval_many(jnp.asarray(xs)))\n",
        "    t3 = time.perf_counter()\n",
        "    out.update({\"y_jax\": y_jax, \"t_jax_ms_hot\": (t3 - t2) * 1e3})\n",
        "\n",
        "    # 数值一致性\n",
        "    out[\"max_abs_diff\"] = float(np.max(np.abs(y_jax - y_np)))\n",
        "    return out\n",
        "\n",
        "\n",
        "# 等距节点\n",
        "xe = nodes_equidistant(-L, L, n)\n",
        "res_e = run_once(xe)\n",
        "\n",
        "# Chebyshev-Lobatto 节点\n",
        "xc = nodes_chebyshev_lobatto(-L, L, n)\n",
        "res_c = run_once(xc)\n",
        "\n",
        "print(f\"[Equidistant]  NumPy: {res_e['t_np_ms']:.2f} ms\", end=\"\")\n",
        "if jax is not None:\n",
        "    print(\n",
        "        f\",  JAX (hot): {res_e['t_jax_ms_hot']:.2f} ms,  max|Δ|={res_e['max_abs_diff']:.2e}\"\n",
        "    )\n",
        "else:\n",
        "    print()\n",
        "\n",
        "print(f\"[Cheb-Lobatto]  NumPy: {res_c['t_np_ms']:.2f} ms\", end=\"\")\n",
        "if jax is not None:\n",
        "    print(\n",
        "        f\",  JAX (hot): {res_c['t_jax_ms_hot']:.2f} ms,  max|Δ|={res_c['max_abs_diff']:.2e}\"\n",
        "    )\n",
        "else:\n",
        "    print()\n",
        "\n",
        "# 画图\n",
        "fig, axes = plt.subplots(2, 2, figsize=(8, 5), sharex=\"col\")\n",
        "\n",
        "# 上：插值曲线\n",
        "axes[0, 0].plot(xs, fx, label=\"f(x)=sinc_π(x)\")\n",
        "axes[0, 0].plot(xs, res_e[\"y_np\"], label=f\"poly (n={n}) @ equidistant\")\n",
        "axes[0, 0].plot(xe, res_e[\"y_nodes\"], \"o\", ms=3, label=\"nodes\")\n",
        "axes[0, 0].set_title(\"等距节点：插值曲线\")\n",
        "axes[0, 0].legend(fontsize=9)\n",
        "axes[0, 0].grid(True, alpha=0.3)\n",
        "\n",
        "axes[0, 1].plot(xs, fx, label=\"f(x)=sinc_π(x)\")\n",
        "axes[0, 1].plot(xs, res_c[\"y_np\"], label=f\"poly (n={n}) @ Chebyshev-Lobatto\")\n",
        "axes[0, 1].plot(xc, res_c[\"y_nodes\"], \"o\", ms=3, label=\"nodes\")\n",
        "axes[0, 1].set_title(\"切比雪夫节点：插值曲线\")\n",
        "axes[0, 1].legend(fontsize=9)\n",
        "axes[0, 1].grid(True, alpha=0.3)\n",
        "\n",
        "# 下：误差（对数 y）\n",
        "e_e = np.abs(res_e[\"y_np\"] - fx)\n",
        "e_c = np.abs(res_c[\"y_np\"] - fx)\n",
        "axes[1, 0].semilogy(xs, e_e)\n",
        "axes[1, 0].set_title(\"等距：|误差|\")\n",
        "axes[1, 0].grid(True, which=\"both\", alpha=0.3)\n",
        "axes[1, 0].set_xlabel(\"x\")\n",
        "\n",
        "axes[1, 1].semilogy(xs, e_c)\n",
        "axes[1, 1].set_title(\"切比雪夫：|误差|\")\n",
        "axes[1, 1].grid(True, which=\"both\", alpha=0.3)\n",
        "axes[1, 1].set_xlabel(\"x\")\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "48696020",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "* **性能**：`NumPy` 与 `JAX (hot)` 的耗时取决于求值点规模与 CPU。对于本例，`JAX` 往往能接近或略优于纯 NumPy 循环实现。首次调用包含编译时间，不用于对比。\n",
        "* **数值**：`max|Δ|` 显示 JAX 与 NumPy 的差异通常在 $10^{-15}$ 量级（同 64-bit）。\n",
        "* **节点**：在高阶时，**Chebyshev–Lobatto** 节点更稳定、边界误差更小。等距节点误差在区间端部更大。"
      ],
      "id": "06a7d394"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/macops/edu/numerical-methods-2025/.venv/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}