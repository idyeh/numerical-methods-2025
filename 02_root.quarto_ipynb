{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"非线性方程求根\"\n",
        "---\n",
        "\n",
        "## 本讲导入\n",
        "\n",
        "* 主题：对非线性方程 $f(x)=0$ 求根\n",
        "* 方法谱系：**二分法**（保序收敛）、**牛顿法**（局部二阶）、**割线法**（超线性）\n",
        "* 评价维度：**收敛阶**、**停止准则**、**数值健壮性**（抵消、溢出、导数退化和发散）\n",
        "\n",
        "## 动机\n",
        "- 大量科学与工程问题都可化为求 $f(x)=0$\n",
        "  - **参数标定 / 反演**：根据观测 $y$ 找参数 $\\theta$，令残差函数 $r(\\theta)=0$。  \n",
        "    例：期权交易的**隐含波动率**（Black–Scholes方程）$\\;C_{\\text{BS}}(\\sigma)-C_{\\text{mkt}}=0$。  \n",
        "  - **天体物理**：**开普勒方程** $E - e\\sin E - M=0$（给定偏心率 $e$、平近点角 $M$ 求偏近点角 $E$）。  \n",
        "  - **机器学习**：一维最优化的一阶必要条件 $\\;f'(x^*)=0$ 等价于求根（多维情形转为方程组）。  \n",
        "- 建立策略选择思维：  \n",
        "  - 有些方法“**必收敛但慢**”（二分法）；有些方法“**快但易发散**”（牛顿法、割线法）。  \n",
        "  - 实际工程中常用**混合**方法：兜底的区间法 + 快速的切线/割线法。\n",
        "\n",
        "::: callout\n",
        "关于 Black–Scholes 定价公式与隐含波动率方程，可设：现价 $S_0$，执行价 $K$，无风险利率 $r$，到期时长 $T>0$，波动率 $\\sigma>0$，标准正态分布的分布函数 $N(\\cdot)$。\n",
        "定义\n",
        "\n",
        "$$\n",
        "d_1=\\frac{\\ln\\!\\frac{S_0}{K}+(r+\\tfrac12\\sigma^2)T}{\\sigma\\sqrt{T}},\n",
        "\\qquad\n",
        "d_2=d_1-\\sigma\\sqrt{T}.\n",
        "$$\n",
        "\n",
        "欧式看涨、看跌期权的 Black–Scholes 价格：\n",
        "\n",
        "$$\n",
        "C_{\\mathrm{BS}}(\\sigma)=S_0\\,N(d_1)-K\\,e^{-rT}N(d_2),\n",
        "$$\n",
        "\n",
        "$$\n",
        "P_{\\mathrm{BS}}(\\sigma)=K\\,e^{-rT}N(-d_2)-S_0\\,N(-d_1).\n",
        "$$\n",
        "\n",
        "隐含波动率方程写作：\n",
        "\n",
        "$$\n",
        "f_{\\text{call}}(\\sigma)=C_{\\mathrm{BS}}(\\sigma)-C_{\\text{mkt}}=0,\n",
        "\\qquad\n",
        "f_{\\text{put}}(\\sigma)=P_{\\mathrm{BS}}(\\sigma)-P_{\\text{mkt}}=0.\n",
        "$$\n",
        "\n",
        "若标的支付连续复利的红利率 $q$，则\n",
        "\n",
        "$$\n",
        "d_1=\\frac{\\ln\\!\\frac{S_0}{K}+\\bigl(r-q+\\tfrac12\\sigma^2\\bigr)T}{\\sigma\\sqrt{T}},\n",
        "\\qquad\n",
        "d_2=d_1-\\sigma\\sqrt{T},\n",
        "$$\n",
        "\n",
        "$$\n",
        "C_{\\mathrm{BS}}(\\sigma)=S_0e^{-qT}N(d_1)-K e^{-rT}N(d_2),\n",
        "$$\n",
        "\n",
        "$$\n",
        "P_{\\mathrm{BS}}(\\sigma)=K e^{-rT}N(-d_2)-S_0e^{-qT}N(-d_1).\n",
        "$$\n",
        "\n",
        "隐含波动率方程同上：令 $C_{\\mathrm{BS}}(\\sigma)=C_{\\text{mkt}}$（或 $P_{\\mathrm{BS}}(\\sigma)=P_{\\text{mkt}}$），对 $\\sigma$ 求解。\n",
        ":::\n",
        "\n",
        "::: callout\n",
        "关于开普勒方程的简短推导。首先椭圆上一点的坐标可用偏近点角 $E$ 表为\n",
        "\n",
        "$$\n",
        "  x = a(\\cos E - e),\\qquad y = b\\sin E,\\qquad b=a\\sqrt{1-e^2}.\n",
        "$$\n",
        "\n",
        "由此立刻得到径向距离\n",
        "\n",
        "$$\n",
        "  r=\\sqrt{x^2+y^2}\n",
        "   = a\\sqrt{(\\cos E-e)^2+(1-e^2)\\sin^2E}\n",
        "   = a\\,(1-e\\cos E).\n",
        "$$\n",
        "\n",
        "以焦点为极点，扫过的面积从近拱点（$E=0$）积到 $E$ 为\n",
        "\n",
        "$$\n",
        "  A(E)\n",
        "  = \\frac12\\int_{0}^{E}\\bigl(x\\,dy - y\\,dx\\bigr)\n",
        "  = \\frac12\\int_{0}^{E}ab\\,[1-e\\cos u]\\,du\n",
        "  = \\frac{ab}{2}\\,\\bigl(E - e\\sin E\\bigr).\n",
        "$$\n",
        "\n",
        "上式用到 $dx=-a\\sin u\\,du,\\ dy=b\\cos u\\,du$。\n",
        "\n",
        "根据开普勒第二定律：单位时间扫过面积恒定。设轨道周期为 $T$，整椭圆面积为 $\\pi ab$，则\n",
        "\n",
        "$$\n",
        "  \\frac{dA}{dt}=\\frac{\\pi ab}{T}\n",
        "  \\quad\\Rightarrow\\quad\n",
        "  A(E)=\\frac{\\pi ab}{T}\\,(t-\\tau),\n",
        "$$\n",
        "\n",
        "其中 $\\tau$ 为近拱点通过时刻。令平近点角\n",
        "\n",
        "$$\n",
        "  M \\;\\equiv\\; n(t-\\tau),\\qquad n=\\frac{2\\pi}{T},\n",
        "$$\n",
        "\n",
        "则上式与 $A(E)=\\frac{ab}{2}(E-e\\sin E)$ 比较得\n",
        "\n",
        "$$\n",
        "  \\,M \\;=\\; E - e\\sin E\\,\n",
        "$$\n",
        "\n",
        "这就是**开普勒方程**。给定 $M$（即时间），通过求解上式的根可得到 $E$。\n",
        ":::\n",
        "\n",
        "## 问题刻画与术语\n",
        "\n",
        "* 目标：求 $x^*$ 使得 $f(x^*)=0$\n",
        "* **根的类型**：简单根 $f'(x^*)\\neq 0$、重根 $f'(x^*)=0$\n",
        "* **收敛阶 $p$**：定义误差 $e_k=|x_k-x^*|$。若 $\\lim_{k\\to\\infty}\\dfrac{|e_{k+1}|}{|e_k|^p}=C\\in(0,\\infty)$，则称序列 $\\{x_k\\}$ 以阶 $p$ 收敛到 $x^*$\n",
        "\n",
        "  * 线性：$p=1$；二阶：$p=2$；超线性：$1<p<2$\n",
        "* **停止准则**\n",
        "\n",
        "  1. **步长准则**：$|x_{k+1}-x_k| \\le \\max(\\text{xtol},\\,\\text{rtol}\\cdot|x_{k+1}|)$\n",
        "  2. **残差准则**：$|f(x_{k+1})| \\le \\text{ftol}$\n",
        "\n",
        "## 二分法\n",
        "\n",
        "二分法（bisection）是保序线性收敛的“兜底”方法\n",
        "\n",
        "* 条件：存在区间 $[a,b]$ 使 $f(a)\\cdot f(b)\\le 0$（变号或端点为根）\n",
        "* 迭代：反复取中点 $c=(a+b)/2$，用符号决定保留的半区间\n",
        "* 性质：**单调**缩小区间（区间长度每步减半），**线性收敛**，不会发散；无需计算导数\n",
        "* 用途：兜底保障\n",
        "\n",
        "### 算法伪代码\n",
        "```text\n",
        "Input: f, a, b, xtol, ftol, maxit\n",
        "Require: f(a)*f(b) ≤ 0\n",
        "for k = 1..maxit:\n",
        "    c = (a + b)/2\n",
        "    if |f(c)| ≤ ftol or (b - a)/2 ≤ xtol*(1+|c|):\n",
        "        return c\n",
        "    if f(a)*f(c) ≤ 0:\n",
        "        b ← c\n",
        "    else:\n",
        "        a ← c\n",
        "return c   # 达到迭代上限，返回当前中点\n",
        "```\n",
        "\n",
        "停止准则：残差 $∣f(c)∣$ 足够小或区间半径足够小（含相对阈值），并设 `maxit` 上限\n",
        "\n",
        "### 二分法 NumPy 实现"
      ],
      "id": "5098b6a1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "def bisect(f, a, b, xtol=1e-12, ftol=1e-12, maxit=100):\n",
        "    fa, fb = f(a), f(b)\n",
        "    if not np.isfinite(fa) or not np.isfinite(fb):\n",
        "        raise ValueError(\"f(a) or f(b) is not finite.\")\n",
        "    if fa*fb > 0:\n",
        "        raise ValueError(\"Sign(a) and Sign(b) must differ (or include zero).\")\n",
        "    for k in range(1, maxit+1):\n",
        "        c = 0.5 * (a + b)\n",
        "        fc = f(c)\n",
        "        if not np.isfinite(fc):\n",
        "            raise FloatingPointError(\"f(mid) is not finite.\")\n",
        "        # 停止：残差或区间长度\n",
        "        if abs(fc) <= ftol or 0.5*(b-a) <= xtol*(1+abs(c)):\n",
        "            return c, k\n",
        "        # 方向更新\n",
        "        if fa*fc <= 0:\n",
        "            b, fb = c, fc\n",
        "        else:\n",
        "            a, fa = c, fc\n",
        "    return c, maxit  # 达到迭代上限也返回当前估计"
      ],
      "id": "6ddd2874",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 迭代过程示意\n",
        "**示例函数**：$f(x)=x^2-2$，根为 $\\sqrt{2}\\approx 1.4142$，初始区间 $[1,2]$。  "
      ],
      "id": "693d6e42"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | code-fold: true\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "\n",
        "def f(x):\n",
        "    return x**2 - 2.0\n",
        "\n",
        "\n",
        "# 记录前6步二分迭代\n",
        "a, b = 1.0, 2.0\n",
        "maxit = 6\n",
        "midpoints, intervals = [], []\n",
        "for k in range(maxit):\n",
        "    c = 0.5 * (a + b)\n",
        "    midpoints.append(c)\n",
        "    intervals.append((a, b))\n",
        "    if f(a) * f(c) <= 0:\n",
        "        b = c\n",
        "    else:\n",
        "        a = c\n",
        "\n",
        "xx = np.linspace(0.8, 2.2, 400)\n",
        "yy = f(xx)\n",
        "\n",
        "plt.figure(figsize=(7, 4))\n",
        "plt.axhline(0, color=\"k\", linewidth=1)\n",
        "plt.plot(xx, yy, label=r\"$f(x)=x^2-2$\")\n",
        "# 画出每步的区间与中点\n",
        "for k, (ab, c) in enumerate(zip(intervals, midpoints), start=1):\n",
        "    a_k, b_k = ab\n",
        "    plt.plot([a_k, a_k], [-1.5, 1.5], \"k--\", alpha=0.2)\n",
        "    plt.plot([b_k, b_k], [-1.5, 1.5], \"k--\", alpha=0.2)\n",
        "    plt.plot(c, f(c), \"o\", color=\"C1\")\n",
        "    plt.annotate(\n",
        "        f\"{k}\",\n",
        "        xy=(c, 0),\n",
        "        xytext=(0, 12),\n",
        "        textcoords=\"offset points\",\n",
        "        ha=\"center\",\n",
        "        color=\"C1\",\n",
        "        alpha=(k + 1) / (maxit + 1),\n",
        "    )\n",
        "plt.xlim(0.9, 2.1)\n",
        "plt.ylim(-1.5, 2.0)\n",
        "plt.legend()\n",
        "plt.title(f\"Bisection: intervals and midpoints (first {maxit} steps)\")\n",
        "plt.xlabel(\"x\")\n",
        "plt.ylabel(\"f(x)\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "2ad6bf63",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 牛顿法\n",
        "\n",
        "牛顿法（Newton）是局部二阶收敛的主力方法\n",
        "\n",
        "* 迭代：\n",
        "$$\n",
        "x_{k+1} = x_k - \\displaystyle\\frac{f(x_k)}{f'(x_k)}\n",
        "$$\n",
        "\n",
        "* 在**简单根**附近，若初值充分接近，通常**二阶收敛**\n",
        "* 风险：\n",
        "  * 远离根时可能发散\n",
        "  * 当 $f'(x_k)\\approx 0$ 时步长爆炸\n",
        "\n",
        "::: callout-tip\n",
        "标准牛顿步 $\\Delta x = -f(x)/f'(x)$ 可能过大导致发散或越界。\n",
        "\n",
        "- **阻尼（damping）**用缩放因子 $\\lambda\\in(0,1]$ 更新 $x_{\\text{new}} = x - \\lambda\\,\\dfrac{f(x)}{f'(x)}$。  \n",
        "- **回溯（backtracking）**则是从 $\\lambda=1$ 开始，若不满足**接受准则**（如 $|f(x_{\\text{new}})|<|f(x)|$），就令 $\\lambda \\leftarrow \\beta\\lambda$（如 $\\beta=0.5$ 即“折半”）逐渐缩小，直到满足。  \n",
        "\n",
        "如此一来，在远离根或导数异常时提升**稳健性**；在近根区域通常仍能获得二阶收敛。\n",
        ":::\n",
        "\n",
        "### 牛顿法 NumPy 实现"
      ],
      "id": "e9517030"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "def newton(f, df, x0, xtol=1e-12, ftol=1e-12, maxit=50, damping=True):\n",
        "    x = float(x0)\n",
        "    fx = f(x)\n",
        "    for k in range(1, maxit+1):\n",
        "        if abs(fx) <= ftol:\n",
        "            return x, k\n",
        "        dfx = df(x)\n",
        "        if not np.isfinite(dfx) or dfx == 0.0:\n",
        "            raise ZeroDivisionError(\"Derivative is zero or non-finite.\")\n",
        "        step = fx/dfx\n",
        "        if damping:\n",
        "            lam = 1.0\n",
        "            # 回溯线搜索：保证 |f(x - lam*step)| < |f(x)|\n",
        "            for _ in range(20):\n",
        "                xn = x - lam*step\n",
        "                fn = f(xn)\n",
        "                if np.isfinite(fn) and abs(fn) < abs(fx):\n",
        "                    break\n",
        "                lam *= 0.5\n",
        "            x_prev, x, fx = x, xn, fn\n",
        "        else:\n",
        "            x_prev, x = x, x - step\n",
        "            fx = f(x)\n",
        "        # 步长停止\n",
        "        if abs(x - x_prev) <= max(xtol, xtol*abs(x)):\n",
        "            return x, k\n",
        "    return x, maxit"
      ],
      "id": "0df6e5de",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 迭代过程示意\n",
        "同样使用 $f(x)=x^2-2$，从初值 $x_0=1.5$ 出发，展示前 4 步的切线与交点。"
      ],
      "id": "d8ae2155"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | code-fold: true\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "\n",
        "def f(x):\n",
        "    return x**2 - 2.0\n",
        "\n",
        "\n",
        "def df(x):\n",
        "    return 2.0 * x\n",
        "\n",
        "\n",
        "# 生成牛顿迭代轨迹\n",
        "xs = [1.5]\n",
        "maxit = 4\n",
        "for _ in range(maxit):\n",
        "    x = xs[-1]\n",
        "    x_new = x - f(x) / df(x)\n",
        "    xs.append(x_new)\n",
        "\n",
        "xx = np.linspace(0.8, 2.2, 400)\n",
        "yy = f(xx)\n",
        "\n",
        "plt.figure(figsize=(7, 4))\n",
        "plt.axhline(0, color=\"k\", linewidth=1)\n",
        "plt.plot(xx, yy, label=r\"$f(x)=x^2-2$\")\n",
        "\n",
        "# 绘制每一步的切线与交点\n",
        "for k in range(len(xs) - 1):\n",
        "    xk, xk1 = xs[k], xs[k + 1]\n",
        "    # 切线： y = f(xk) + f'(xk)*(x - xk)\n",
        "    yk = f(xk)\n",
        "    gk = df(xk)\n",
        "    xt = np.linspace(xk - 0.6, xk + 0.6, 50)\n",
        "    yt = yk + gk * (xt - xk)\n",
        "    plt.plot(xt, yt, \"--\", color=\"C2\", alpha=0.8)\n",
        "    # 标注 x_k 与 x_{k+1}\n",
        "    plt.plot(xk, f(xk), \"o\", color=\"C2\")\n",
        "    plt.annotate(\n",
        "        f\"${k}$\",\n",
        "        xy=(xk, f(xk)),\n",
        "        xytext=(5, 8),\n",
        "        textcoords=\"offset points\",\n",
        "        color=\"C2\",\n",
        "        alpha=(k + 1) / (maxit + 1),\n",
        "    )\n",
        "\n",
        "plt.xlim(1.3, 1.51)\n",
        "plt.ylim(-1.5, 2.0)\n",
        "plt.legend()\n",
        "plt.title(f\"Newton: tangents and updates (first {maxit} steps)\")\n",
        "plt.xlabel(\"x\")\n",
        "plt.ylabel(\"f(x)\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "2539ab0d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 导数与差商\n",
        "- **导数（derivative）**：在点 $x$ 处，函数的瞬时变化率  \n",
        "  $$\n",
        "  f'(x) \\;=\\; \\lim_{h\\to 0}\\frac{f(x+h)-f(x)}{h}\n",
        "  $$\n",
        "  其几何意义是切线（tangent）的斜率\n",
        "- 一阶**差商（difference quotient）**：给定两点 $x_{k-1},x_k$，\n",
        "  $$\n",
        "  f[x_{k-1},x_k] \\;\\equiv\\; \\frac{f(x_k)-f(x_{k-1})}{x_k-x_{k-1}}\n",
        "  $$\n",
        "  是对 $f'(x)$ 的近似代替，其几何意义是割线（secant）的斜率。有限差分（finite difference）的话题中还会提及\n",
        "- **与两种方法的关系**  \n",
        "  - **牛顿法**用**切线斜率** $f'(x_k)$，需要求导数 \n",
        "  - **割线法**用**差商/差分斜率** $f[x_{k-1},x_k]$ 近似 $f'(x_k)$，不用求导数  \n",
        "\n",
        "\n",
        "## 割线法\n",
        "\n",
        "割线法（secant）是一种避免求导数的超线性方法\n",
        "\n",
        "* 用两次函数值求**割线斜率**近似导数\n",
        "\n",
        "  $$\n",
        "  x_{k+1} = x_k - f(x_k)\\,\\frac{x_k-x_{k-1}}{f(x_k)-f(x_{k-1})}\n",
        "  $$\n",
        "* 收敛阶 $p \\approx 1.618$（超线性）；不需显式计算 $f'(x)$\n",
        "* 风险：分母接近 0；需健壮处理\n",
        "\n",
        "::: callout-note\n",
        "数值健壮性（numerical robustness）是算法对数据/舍入扰动与不良初值的**抵抗力**与**安全退让机制**\n",
        ":::\n",
        "\n",
        "### 割线法：NumPy 实现"
      ],
      "id": "d9894acc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "def secant(f, x0, x1, xtol=1e-12, ftol=1e-12, maxit=80):\n",
        "    x_prev, x = float(x0), float(x1)\n",
        "    f_prev, fx = f(x_prev), f(x)\n",
        "    for k in range(1, maxit+1):\n",
        "        if abs(fx) <= ftol:\n",
        "            return x, k\n",
        "        denom = fx - f_prev\n",
        "        if denom == 0 or not np.isfinite(denom):\n",
        "            raise ZeroDivisionError(\"Denominator near zero or non-finite.\")\n",
        "        step = fx*(x - x_prev)/denom\n",
        "        x_prev, f_prev = x, fx\n",
        "        x = x - step\n",
        "        fx = f(x)\n",
        "        if abs(step) <= max(xtol, xtol*abs(x)):\n",
        "            return x, k\n",
        "    return x, maxit"
      ],
      "id": "ca031950",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 小结：收敛阶与停止准则\n",
        "\n",
        "* **二分法**：线性收敛；停止准则可用区间半长与 $|f|$ 并用\n",
        "* **牛顿法**：理论上是**二阶**，但需满足简单根、初值足够近、$f' \\ne 0$\n",
        "* **割线法**：黄金分割超线性，免导数\n",
        "* 停止准则建议：\n",
        "\n",
        "  * 步长阈值 `xtol` 与 `rtol` 并用，外加残差阈值 `ftol`\n",
        "  * 设置 `maxit` 上限；**失败也应返回**当前最优估计与状态码\n",
        "\n",
        "\n",
        "### 方法对比\n",
        "\n",
        "求解 $f(x)=\\cos x - x$ 在 $[0,1]$ 上的根"
      ],
      "id": "2130e9f0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "\n",
        "def f(x):\n",
        "    return np.cos(x) - x\n",
        "\n",
        "\n",
        "def df(x):\n",
        "    return -np.sin(x) - 1.0\n",
        "\n",
        "\n",
        "root_true = 0.73908513321516064166  # 参考\n",
        "\n",
        "# 二分需先找变号区间\n",
        "x_bi, it_bi = bisect(f, 0.0, 1.0)\n",
        "x_nt, it_nt = newton(f, df, x0=0.5, damping=True)\n",
        "x_sc, it_sc = secant(f, 0.0, 1.0)\n",
        "\n",
        "print(\"bisect :\", x_bi, it_bi, abs(x_bi - root_true))\n",
        "print(\"newton :\", x_nt, it_nt, abs(x_nt - root_true))\n",
        "print(\"secant :\", x_sc, it_sc, abs(x_sc - root_true))"
      ],
      "id": "bb04ed73",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 编写单元测试"
      ],
      "id": "02bd4d8f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def approx(a, b, tol=1e-10):\n",
        "    return abs(a - b) <= tol * (1 + max(abs(a), abs(b)))\n",
        "\n",
        "\n",
        "def test_root_cosx_minus_x():\n",
        "    r, it = newton(lambda x: np.cos(x) - x, lambda x: -np.sin(x) - 1, 0.5)\n",
        "    assert approx(r, root_true, 1e-10)\n",
        "\n",
        "\n",
        "def test_bisect_sign_change():\n",
        "    r, it = bisect(lambda x: (x - 1) * (x + 2), -1, 2)\n",
        "    assert approx(r, 1.0, 1e-12)\n",
        "\n",
        "\n",
        "def test_secant_basic():\n",
        "    r, it = secant(lambda x: x**2 - 2, 0.0, 2.0)\n",
        "    assert approx(r, np.sqrt(2.0), 1e-10)\n",
        "\n",
        "\n",
        "test_root_cosx_minus_x()\n",
        "test_bisect_sign_change()\n",
        "test_secant_basic()\n",
        "print(\"unit tests passed\")"
      ],
      "id": "832a5584",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 数值健壮性：常见问题与对策\n",
        "\n",
        "* **导数退化**：$f'(x)\\approx 0$ 牛顿步长过大，考虑启用**阻尼（回溯线搜索）**或**混合法（区间约束）**\n",
        "* 远离根或不良构函数会**发散**，先用**扫描法**找**变号区间**，再用二分或混合法兜底\n",
        "* 迭代上限、数值非有限（`NaN` / `Inf`）时返回当前最优估计与状态码\n",
        "* 必要时对变量/函数进行缩放，减少过小/过大量级造成的舍入放大\n",
        "\n",
        "## 重根问题\n",
        "- 若 $f(x)=(x-x^*)^m g(x)$，且 $g(x^*)\\neq 0$，则 $x^*$ 为**重根（multiple roots）**，重数 $m>1$。  \n",
        "- 标准牛顿在重根处仅**线性收敛**，误差递推近似\n",
        "  $$\n",
        "  e_{k+1} \\;\\approx\\; \\frac{m-1}{m}\\,e_k, \\quad e_k=|x_k-x^*|.\n",
        "  $$\n",
        "- 可作以下改进：  \n",
        "  1. **修正牛顿法**（若已知 $m$）  \n",
        "     $$\n",
        "     x_{k+1}\\;=\\;x_k - \\frac{m\\,f(x_k)}{f'(x_k)}.\n",
        "     $$\n",
        "  2. **自适应估计 $m$**（需二阶导，或用差分近似）  \n",
        "     $$\n",
        "     \\hat m(x)\\;=\\;\\frac{[f'(x)]^2}{f'(x)^2 - f(x)f''(x)}\n",
        "     $$\n",
        "     然后令 $x_{k+1}=x_k-\\hat m(x_k)\\,f(x_k)/f'(x_k)$。  \n",
        "  3. **混合法**：保持区间约束（如二分/截距回退），防止大步发散。\n",
        "\n",
        "### 重根问题：示例\n",
        "$f(x)=(x-1)^2$，以 $x_0=1.5$。注意对比标准牛顿和修正牛顿的表现"
      ],
      "id": "2ca920a8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | code-fold: true\n",
        "import numpy as np\n",
        "\n",
        "\n",
        "# 重根示例：f(x) = (x-1)^2\n",
        "def f(x):\n",
        "    return (x - 1.0) ** 2\n",
        "\n",
        "\n",
        "def df(x):\n",
        "    return 2.0 * (x - 1.0)\n",
        "\n",
        "\n",
        "def newton_standard(x0, it=5, xtol=1e-12, ftol=1e-12):\n",
        "    \"\"\"标准牛顿\"\"\"\n",
        "    xs = [float(x0)]\n",
        "    for _ in range(it):\n",
        "        x = xs[-1]\n",
        "        fx = f(x)\n",
        "        # 先检查是否已到根或非常接近根\n",
        "        if abs(fx) <= ftol:\n",
        "            break\n",
        "        dfx = df(x)\n",
        "        if dfx == 0.0 or not np.isfinite(dfx):\n",
        "            # 导数为零/非有限时直接退出，或可切换到兜底策略\n",
        "            break\n",
        "        x_new = x - fx / dfx\n",
        "        xs.append(x_new)\n",
        "        if abs(x_new - x) <= xtol * (1.0 + abs(x_new)):\n",
        "            break\n",
        "    return xs\n",
        "\n",
        "\n",
        "def newton_modified(x0, m=2, it=5, xtol=1e-12, ftol=1e-12):\n",
        "    \"\"\"修正牛顿（已知重数 m）。先判断 |f(x)| 再做除法，避免 f'=0 时除零。\"\"\"\n",
        "    xs = [float(x0)]\n",
        "    for _ in range(it):\n",
        "        x = xs[-1]\n",
        "        fx = f(x)\n",
        "        # 先检查是否已到根或非常接近根\n",
        "        if abs(fx) <= ftol:\n",
        "            break\n",
        "        dfx = df(x)\n",
        "        if dfx == 0.0 or not np.isfinite(dfx):\n",
        "            # 对于重根例子，若已非常接近根，f'(x) 可能为 0，此时直接退出即可\n",
        "            break\n",
        "        x_new = x - m * fx / dfx\n",
        "        xs.append(x_new)\n",
        "        if abs(x_new - x) <= xtol * (1.0 + abs(x_new)):\n",
        "            break\n",
        "    return xs\n",
        "\n",
        "\n",
        "xs_std = newton_standard(1.5, it=5)\n",
        "xs_mod = newton_modified(1.5, m=2, it=5)\n",
        "\n",
        "print(\"standard newton:\", xs_std)\n",
        "print(\"modified newton:\", xs_mod)"
      ],
      "id": "d01ec58b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 抵消现象\n",
        "\n",
        "- 当计算 $f(x)$ 本身就含有“两大数相减”的结构时，靠近根的区域可能出现**灾难性抵消**，使得\n",
        "\n",
        "  1. $f(x)$ 的有效位数损失，残差评估不可靠；  \n",
        "  2. 牛顿步 $f(x)/f'(x)$ 因**分子/分母同为小量**而放大舍入误差。\n",
        "- 因此要对 $f$ 做**稳定重写**，或使用**特化函数**，例如：\n",
        "  - $f(x)=\\sqrt{1+x}-1$（根在 $x^*=0$）的稳定式：$\\displaystyle f(x)=\\frac{x}{\\sqrt{1+x}+1}$  \n",
        "  - $f(x)=1-\\cos x$（根在 $x^*=0$）的稳定式：$\\displaystyle f(x)=2\\sin^2\\!\\frac{x}{2}$\n",
        "\n",
        "::: callout-tip\n",
        "在建模阶段优先选择稳定等价形式的 $f$；在实现阶段对“非常接近 0 的差值/比值”加阈值保护与混合步，如失败则回退到区间法。\n",
        ":::\n",
        "\n",
        "\n",
        "## 附：牛顿法的数学推导\n",
        "\n",
        "**目标**：求解 $f(x)=0$ 的根 $x^*$，在迭代点 $x_k$ 附近构造线性近似并求其零点，得到更新公式。\n",
        "\n",
        "**前提**\n",
        "\n",
        "* $f\\in C^2$ 于 $x^*$ 的邻域；\n",
        "* $f(x^*)=0,\\; f'(x^*)\\neq 0$；\n",
        "* 迭代点 $x_k$ 充分接近 $x^*$（从而 $x_k\\to x^*$）。\n",
        "\n",
        "**1. 局部线性化**  \n",
        "在 $x_k$ 处对 $f$ 作拉格朗日余项形式的一阶泰勒展开：\n",
        "$$\n",
        "f(x)\\;=\\;f(x_k)+f'(x_k)(x-x_k)+R_2(x;x_k),\\qquad\n",
        "R_2(x;x_k)=\\displaystyle\\frac12 f''(\\xi_k)\\,(x-x_k)^2\n",
        "$$\n",
        "\n",
        "其中 $\\xi_k$ 位于 $x$ 与 $x_k$ 之间。\n",
        "\n",
        "**2. 用线性近似的零点替代原方程的零点**  \n",
        "忽略二阶余项 $R_2$，把线性近似的零点当作下一次迭代值 $\\,x_{k+1}$：\n",
        "$$\n",
        "0 \\approx f(x_k)+f'(x_k)(x_{k+1}-x_k)\n",
        "\\;\\Rightarrow\\;\n",
        "x_{k+1} \\;=\\; x_k - \\frac{f(x_k)}{f'(x_k)}.\n",
        "$$\n",
        "\n",
        "这就是**牛顿法**（Newton’s method）迭代式\n",
        "\n",
        "## 附：牛顿法二阶收敛证明\n",
        "\n",
        "设 $x^*$ 为**简单根**（$f(x^*)=0,\\;f'(x^*)\\neq 0$），记误差 $e_k=x_k-x^*$。  \n",
        "对 $f(x_k)$ 在 $x^*$ 处作二阶泰勒展开：\n",
        "$$\n",
        "f(x_k)=f'(x^*)\\,e_k+\\frac12 f''(\\zeta_k)\\,e_k^2,\n",
        "\\qquad \\zeta_k \\text{ 介于 } x_k \\text{ 与 } x^* \\text{ 之间}.\n",
        "$$\n",
        "\n",
        "对 $f'(x_k)$ 在 $x^*$ 处作一阶展开：\n",
        "$$\n",
        "f'(x_k)=f'(x^*)+f''(\\eta_k)\\,e_k,\n",
        "\\qquad \\eta_k \\text{ 介于 } x_k \\text{ 与 } x^* \\text{ 之间}.\n",
        "$$\n",
        "\n",
        "代入牛顿法迭代式并化为误差形式：\n",
        "$$\n",
        "\\begin{aligned}\n",
        "e_{k+1}\n",
        "&=x_{k+1}-x^*\n",
        "= x_k - x^* - \\frac{f(x_k)}{f'(x_k)}\n",
        "= e_k - \\frac{f'(x^*)e_k + \\frac12 f''(\\zeta_k)e_k^2}{\\,f'(x^*)+f''(\\eta_k)e_k\\,}.\n",
        "\\end{aligned}\n",
        "$$\n",
        "\n",
        "提取公因子并做严格代数整理，先从分子提取 $e_k$，得到\n",
        "\n",
        "$$\n",
        "e_{k+1}\n",
        "= e_k - e_k\\cdot \\frac{\\,f'(x^*) + \\frac12 f''(\\zeta_k)e_k\\,}{\\,f'(x^*) + f''(\\eta_k)e_k\\,}.\n",
        "$$\n",
        "\n",
        "把右侧写成一个共同分母的差：\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "e_{k+1}\n",
        "&= e_k\\cdot\n",
        "\\frac{\\,\\bigl(f'(x^*)+f''(\\eta_k)e_k\\bigr) - \\bigl(f'(x^*) + \\frac12 f''(\\zeta_k)e_k\\bigr)\\,}\n",
        "{\\,f'(x^*) + f''(\\eta_k)e_k\\,} \\\\\n",
        "&= e_k\\cdot\n",
        "\\frac{\\,\\bigl(f''(\\eta_k)-\\frac12 f''(\\zeta_k)\\bigr)e_k\\,}\n",
        "{\\,f'(x^*) + f''(\\eta_k)e_k\\,}.\n",
        "\\end{aligned}\n",
        "$$\n",
        "\n",
        "于是得到**含误差项的精确表达式**：\n",
        "\n",
        "$$\n",
        "\\boxed{%\n",
        "\\displaystyle\n",
        "e_{k+1}\n",
        "= \\frac{\\,f''(\\eta_k)-\\frac12 f''(\\zeta_k)\\,}{\\,f'(x^*) + f''(\\eta_k)e_k\\,}\\; e_k^{\\,2}.\n",
        "}\n",
        "\\tag{★}\n",
        "$$\n",
        "\n",
        "> $\\eta_k$ 和 $\\zeta_k$ 是由均值定理保证存在的点。\n",
        "\n",
        "将（★）两边取绝对值并除以 $|e_k|^2$：\n",
        "\n",
        "$$\n",
        "\\frac{|e_{k+1}|}{|e_k|^2}\n",
        "= \\frac{\\,\\bigl|\\,f''(\\eta_k)-\\frac12 f''(\\zeta_k)\\,\\bigr|\\,}\n",
        "{\\,\\bigl|\\,f'(x^*) + f''(\\eta_k)e_k\\,\\bigr|\\,}.\n",
        "$$\n",
        "\n",
        "* 因 $x_k\\to x^*$ 且 $\\eta_k,\\zeta_k$ 位于 $x_k$ 与 $x^*$ 之间，故 $\\eta_k\\to x^*$, $\\zeta_k\\to x^*$。\n",
        "* $e_k\\to 0$。\n",
        "* 由连续性，$f''(\\eta_k)\\to f''(x^*)$, $f''(\\zeta_k)\\to f''(x^*)$。\n",
        "* 分母 $\\;f'(x^*) + f''(\\eta_k)e_k \\to f'(x^*) \\neq 0$。因此，对充分大的 $k$，分母保持**远离 0**，可合法进行极限的分式运算。\n",
        "\n",
        "据此，对上式直接取极限，并利用极限与连续函数复合的交换性：\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "\\lim_{k\\to\\infty}\\frac{|e_{k+1}|}{|e_k|^2}\n",
        "&= \\frac{\\,\\bigl|\\; \\lim_{k\\to\\infty}\\bigl(f''(\\eta_k)-\\tfrac12 f''(\\zeta_k)\\bigr)\\;\\bigr|\\,}\n",
        "{\\,\\bigl|\\; \\lim_{k\\to\\infty}\\bigl(f'(x^*) + f''(\\eta_k)e_k\\bigr)\\;\\bigr|\\,} \\\\\n",
        "&= \\frac{\\,\\bigl|\\, f''(x^*) - \\tfrac12 f''(x^*) \\,\\bigr|\\,}{\\,|\\,f'(x^*)\\,|} \\\\\n",
        "&= \\left|\\frac{f''(x^*)}{2\\,f'(x^*)}\\right|\\in(0,\\infty).\n",
        "\\end{aligned}\n",
        "$$\n",
        "\n",
        "从而确立**二阶收敛**。\n",
        "\n",
        "\n",
        "## 附：收敛阶的直观估计实验\n",
        "\n",
        "比较二分法/牛顿法/割线法在\n",
        "$f(x)=x^2-2$（真根 $x^*=\\sqrt{2}$）上的误差衰减与**局部收敛阶**估计。\n",
        "\n",
        "- 上图：$\\log_{10} |e_k|$ 随迭代步 $k$ 的变化\n",
        "- 下图：用公式\n",
        "  $$\n",
        "  p_k \\;=\\; \\frac{\\log(e_{k+1}/e_k)}{\\log(e_k/e_{k-1})}\n",
        "  $$\n",
        "  估计**局部阶**，观察其趋向：二分 $\\to 1$，割线 $\\to 1.618$，牛顿 $\\to 2$"
      ],
      "id": "9ef0e36f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | code-fold: true\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "\n",
        "# 问题与真根\n",
        "def f(x):\n",
        "    return x**2 - 2.0\n",
        "\n",
        "\n",
        "def df(x):\n",
        "    return 2.0 * x\n",
        "\n",
        "\n",
        "def significance_floor(xstar, rtol=1e-15, atol=0.0):\n",
        "    \"\"\"返回绘图/估计用的意义下限\"\"\"\n",
        "    return max(atol, rtol * max(1.0, abs(xstar)))\n",
        "\n",
        "\n",
        "xstar = np.sqrt(2.0)\n",
        "floor_plot = significance_floor(xstar, rtol=1e-15)  # ~1e-15\n",
        "floor_order = significance_floor(xstar, rtol=1e-14)  # ~1e-14\n",
        "\n",
        "\n",
        "# 三种方法的轨迹实现\n",
        "def trace_bisection(f, a, b, maxit=30):\n",
        "    \"\"\"记录二分法中点序列，用于误差与收敛阶估计\"\"\"\n",
        "    fa, fb = f(a), f(b)\n",
        "    if fa * fb > 0:\n",
        "        raise ValueError(\"Bisection requires sign change on [a,b].\")\n",
        "    xs = []\n",
        "    for _ in range(maxit):\n",
        "        c = 0.5 * (a + b)\n",
        "        xs.append(c)\n",
        "        fc = f(c)\n",
        "        if fa * fc <= 0:\n",
        "            b, fb = c, fc\n",
        "        else:\n",
        "            a, fa = c, fc\n",
        "    return xs\n",
        "\n",
        "\n",
        "def trace_newton(f, df, x0, maxit=12, xtol=1e-16):\n",
        "    \"\"\"标准牛顿法\"\"\"\n",
        "    xs = [float(x0)]\n",
        "    for _ in range(maxit):\n",
        "        x = xs[-1]\n",
        "        dfx = df(x)\n",
        "        if dfx == 0.0 or not np.isfinite(dfx):\n",
        "            break\n",
        "        step = f(x) / dfx\n",
        "        if abs(f(x)) <= floor_plot:\n",
        "            break\n",
        "        x_new = x - step\n",
        "        xs.append(x_new)\n",
        "        if abs(x_new - x) <= xtol * (1 + abs(x_new)):\n",
        "            break\n",
        "    return xs\n",
        "\n",
        "\n",
        "def trace_secant(f, x0, x1, maxit=20, xtol=1e-16):\n",
        "    \"\"\"割线法\"\"\"\n",
        "    xs = [float(x0), float(x1)]\n",
        "    for _ in range(maxit):\n",
        "        x_prev, x = xs[-2], xs[-1]\n",
        "        f_prev, fx = f(x_prev), f(x)\n",
        "        denom = fx - f_prev\n",
        "        if denom == 0.0 or not np.isfinite(denom):\n",
        "            break\n",
        "        step = fx * (x - x_prev) / denom\n",
        "        if step == 0.0:\n",
        "            break\n",
        "        x_new = x - step\n",
        "        xs.append(x_new)\n",
        "        if abs(x_new - x) <= xtol * (1 + abs(x_new)):\n",
        "            break\n",
        "    return xs\n",
        "\n",
        "\n",
        "# 局部收敛阶估计\n",
        "def estimate_order_sequence(xs, xstar, floor_order: float):\n",
        "    \"\"\"\n",
        "    返回 p_k 序列，k=2..\n",
        "    \"\"\"\n",
        "    errs = np.abs(np.asarray(xs) - xstar)\n",
        "    pks, ks = [], []\n",
        "    # 仅在 e_{k-1}, e_k, e_{k+1} 都正且可算时才估计\n",
        "    for k in range(2, len(errs) - 1):\n",
        "        ekm1, ek, ekp1 = errs[k - 1], errs[k], errs[k + 1]\n",
        "        if (ekm1 > floor_order) and (ek > floor_order) and (ekp1 > floor_order):\n",
        "            num = np.log(ekp1 / ek)\n",
        "            den = np.log(ek / ekm1)\n",
        "            if np.isfinite(num) and np.isfinite(den) and den != 0.0:\n",
        "                pks.append(num / den)\n",
        "                ks.append(k)  # 对应以 x_k 为中心的局部阶\n",
        "    return np.asarray(ks), np.asarray(pks), errs\n",
        "\n",
        "\n",
        "def tail_mean(x, m=5):\n",
        "    return np.mean(x[-m:]) if len(x) >= m else np.mean(x) if len(x) else np.nan\n",
        "\n",
        "\n",
        "def plot_safe_errors(errs: np.ndarray, floor: float) -> np.ndarray:\n",
        "    \"\"\"绘图专用：去掉尾部 <= floor 的误差点，再裁到 floor，保证 log10 可用\"\"\"\n",
        "    idx = np.where(errs > floor)[0]\n",
        "    e = errs[:0] if len(idx) == 0 else errs[: idx[-1] + 1]\n",
        "    return np.clip(e, floor, None)\n",
        "\n",
        "\n",
        "# 生成轨迹\n",
        "xs_bi = trace_bisection(f, 1.0, 2.0, maxit=30)  # 线性收敛\n",
        "xs_nt = trace_newton(f, df, x0=1.5, maxit=12)  # 二阶收敛\n",
        "xs_sc = trace_secant(f, 1.0, 2.0, maxit=20)  # 超线性\n",
        "\n",
        "# 估计局部阶\n",
        "k_bi, p_bi, e_bi = estimate_order_sequence(xs_bi, xstar, floor_order)\n",
        "k_nt, p_nt, e_nt = estimate_order_sequence(xs_nt, xstar, floor_order)\n",
        "k_sc, p_sc, e_sc = estimate_order_sequence(xs_sc, xstar, floor_order)\n",
        "\n",
        "\n",
        "p_bi_hat = tail_mean(p_bi, m=5)\n",
        "p_nt_hat = tail_mean(p_nt, m=3)\n",
        "p_sc_hat = tail_mean(p_sc, m=5)\n",
        "\n",
        "print(f\"bisect : steps={len(xs_bi):2d}, tail p ≈ {p_bi_hat:.3f}\")\n",
        "print(f\"newton : steps={len(xs_nt):2d}, tail p ≈ {p_nt_hat:.3f}\")\n",
        "print(f\"secant : steps={len(xs_sc):2d}, tail p ≈ {p_sc_hat:.3f}\")\n",
        "\n",
        "# 绘图误差\n",
        "e_bi_plot = plot_safe_errors(np.abs(np.asarray(xs_bi) - xstar), floor_plot)\n",
        "e_nt_plot = plot_safe_errors(np.abs(np.asarray(xs_nt) - xstar), floor_plot)\n",
        "e_sc_plot = plot_safe_errors(np.abs(np.asarray(xs_sc) - xstar), floor_plot)\n",
        "\n",
        "# 可视化\n",
        "fig, axes = plt.subplots(2, 1, figsize=(6, 9))\n",
        "\n",
        "# 误差随迭代步衰减\n",
        "axes[0].plot(\n",
        "    np.arange(len(e_bi_plot)), np.log10(e_bi_plot), \"-o\", ms=4, label=\"Bisection\"\n",
        ")\n",
        "axes[0].plot(np.arange(len(e_nt_plot)), np.log10(e_nt_plot), \"-o\", ms=4, label=\"Newton\")\n",
        "axes[0].plot(np.arange(len(e_sc_plot)), np.log10(e_sc_plot), \"-o\", ms=4, label=\"Secant\")\n",
        "axes[0].set_xlabel(\"iteration k\")\n",
        "axes[0].set_ylabel(r\"$\\log_{10}|e_k|$\")\n",
        "axes[0].set_title(\"Error decay (log-scale)\")\n",
        "axes[0].grid(True, alpha=0.3)\n",
        "axes[0].legend()\n",
        "\n",
        "# 局部收敛阶 p_k\n",
        "axes[1].axhline(1.0, color=\"k\", lw=1, ls=\":\", label=\"p=1 (linear)\")\n",
        "axes[1].axhline((1 + 5**0.5) / 2, color=\"k\", lw=1, ls=\"--\", label=\"p≈1.618 (secant)\")\n",
        "axes[1].axhline(2.0, color=\"k\", lw=1, ls=\"-.\", label=\"p=2 (Newton)\")\n",
        "axes[1].plot(k_bi, p_bi, \"-o\", ms=4, label=\"Bisection p_k\")\n",
        "axes[1].plot(k_nt, p_nt, \"-o\", ms=4, label=\"Newton p_k\")\n",
        "axes[1].plot(k_sc, p_sc, \"-o\", ms=4, label=\"Secant p_k\")\n",
        "axes[1].set_xlabel(\"iteration index k (for p_k)\")\n",
        "axes[1].set_ylabel(r\"local order $p_k$\")\n",
        "axes[1].set_ylim(0.5, 2.4)\n",
        "axes[1].set_title(\"Estimated local order\")\n",
        "axes[1].grid(True, alpha=0.3)\n",
        "axes[1].legend(loc=\"lower right\", fontsize=9)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "6c640b96",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 课后作业\n",
        "\n",
        "### a2-1（必做）：计算题\n",
        "\n",
        "设 $f(x)=\\mathrm{e}^x-3x$，\n",
        "\n",
        "1. 写出牛顿迭代公式；\n",
        "2. 以 $x_0=0$ 迭代 5 次，给出 $|f(x_k)|$；\n",
        "3. 以二分法在 $[0,2]$ 上求根，比较迭代次数与误差。\n",
        "\n",
        "### a2-2（必做）：证明题\n",
        "\n",
        "在 $f'(x^*)\\neq 0$、$f\\in C^2$ 的条件下，证明牛顿法在 $x^*$ 邻域**二阶收敛**。\n",
        "\n",
        "> 提示：泰勒展开 + 误差递推\n",
        "\n",
        "### a2-3（选做）：编程实现**牛顿法变体**并验证\n",
        "\n",
        "* 变体难度相当，**任选1种**：\n",
        "  a) 带回溯线搜索的阻尼牛顿，用 $φ(x)=\\displaystyle\\frac{1}{2}f(x)^2$ 作下降准则\n",
        "  b) 牛顿–二分混合，维持 $[a,b]$ 变号区间，牛顿失败即回退至二分\n",
        "  c) 割线–牛顿混合：前 `k` 步割线，再切换牛顿\n",
        "  d) 中心差分近似导数 $f'$ 的牛顿，中心差分公式：\n",
        "  $$\\mathrm{d}f(x) \\approx \\frac{f(x+h)-f(x-h)}{2h}$$\n",
        "\n",
        "* 要求统一 API、统一停止准则，统一求解 $f(x)=\\cos x - x$ 在 $[0,1]$ 上的根作为测试\n",
        "* 形成带有理论分析、数值计算、性能分析的最终报告。\n",
        "* 代码模版："
      ],
      "id": "37221271"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# ======统一数据结构区======\n",
        "from dataclasses import dataclass\n",
        "import time\n",
        "import math\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "\n",
        "@dataclass\n",
        "class Stop:\n",
        "    \"\"\"\n",
        "    定义求解器停止准则的统一数据结构。\n",
        "\n",
        "    该结构将所有控制算法终止的参数集中管理，\n",
        "    方便统一传递和修改。\n",
        "    \"\"\"\n",
        "\n",
        "    xtol: float = 1e-12  # 步长的绝对容差 (absolute tolerance for x-step)。用于判断 |x_new - x_old| 是否足够小。\n",
        "    ftol: float = 1e-12  # 残差的容差 (function value/residual tolerance)。用于判断 |f(x)| 是否足够接近于零。\n",
        "    rtol: float = 1e-12  # 步长的相对容差 (relative tolerance for x-step)。与 xtol 结合使用，以适应不同数量级的根。\n",
        "    maxit: int = (\n",
        "        50  # 最大迭代次数 (maximum iterations)。防止算法因不收敛而无限循环的保险措施。\n",
        "    )\n",
        "\n",
        "\n",
        "@dataclass\n",
        "class Result:\n",
        "    \"\"\"\n",
        "    定义求解器返回结果的统一数据结构。\n",
        "\n",
        "    该结构封装了求解过程的所有关键信息，\n",
        "    便于后续分析、绘图或报告。\n",
        "    \"\"\"\n",
        "\n",
        "    root: float  # 计算得到的最终根的估计值。\n",
        "    iters: int  # 算法实际执行的迭代次数。\n",
        "    success: bool  # 布尔标志，True 表示算法成功收敛，False 表示未收敛或因其他原因失败。\n",
        "    status: str  # 描述算法终止具体原因的字符串，例如 \"converged(step)\", \"maxit\", \"derivative_zero_or_nonfinite\" 等。\n",
        "    history: list  # 按顺序记录了每次迭代产生的根的估计值 [x0, x1, x2, ...]。\n",
        "    f_calls: int  # 在整个求解过程中，目标函数 f(x) 被调用的总次数，是衡量算法效率的指标之一。\n",
        "    df_calls: int  # 在整个求解过程中，导数函数 f'(x) 被调用的总次数，对于需要导数的方法是关键的效率指标。\n",
        "    elapsed_sec: float  # 算法从开始到结束所消耗的时间，单位为秒。\n",
        "\n",
        "\n",
        "def step_stop(x_new, x_old, stop: Stop) -> bool:\n",
        "    return abs(x_new - x_old) <= max(stop.xtol, stop.rtol * abs(x_new))\n",
        "\n",
        "\n",
        "def res_stop(fx_new, stop: Stop) -> bool:\n",
        "    return abs(fx_new) <= stop.ftol\n",
        "\n",
        "\n",
        "def significance_floor(xstar, rtol=1e-15, atol=0.0) -> float:\n",
        "    return max(atol, rtol * max(1.0, abs(xstar)))\n",
        "\n",
        "\n",
        "def trim_trailing_small(errs: np.ndarray, floor: float) -> np.ndarray:\n",
        "    idx = np.where(errs > floor)[0]\n",
        "    if len(idx) == 0:\n",
        "        return errs[:0]\n",
        "    return errs[: idx[-1] + 1]\n",
        "\n",
        "\n",
        "def plot_safe_errors(errs: np.ndarray, floor: float) -> np.ndarray:\n",
        "    e = trim_trailing_small(errs, floor)\n",
        "    return np.clip(e, floor, None)\n",
        "\n",
        "\n",
        "def estimate_order_sequence(xs, xstar, floor_order: float = 1e-14):\n",
        "    \"\"\"\n",
        "    返回 (k_indices, p_k, errs)，其中\n",
        "      p_k = log(e_{k+1}/e_k) / log(e_k/e_{k-1})\n",
        "    只在三元误差都大于 floor_order 时计算\n",
        "    \"\"\"\n",
        "    errs = np.abs(np.asarray(xs, dtype=float) - xstar)\n",
        "    pks, ks = [], []\n",
        "    for k in range(2, len(errs) - 1):\n",
        "        ekm1, ek, ekp1 = errs[k - 1], errs[k], errs[k + 1]\n",
        "        if (ekm1 > floor_order) and (ek > floor_order) and (ekp1 > floor_order):\n",
        "            num = np.log(ekp1 / ek)\n",
        "            den = np.log(ek / ekm1)\n",
        "            if np.isfinite(num) and np.isfinite(den) and den != 0.0:\n",
        "                pks.append(num / den)\n",
        "                ks.append(k)\n",
        "    return np.asarray(ks), np.asarray(pks), errs\n",
        "\n",
        "\n",
        "def tail_mean(x, m=5):\n",
        "    return np.mean(x[-m:]) if len(x) >= m else (np.mean(x) if len(x) else np.nan)\n",
        "\n",
        "\n",
        "# ======数据结构区结束======\n",
        "\n",
        "\n",
        "# ======下面是作业实现======\n",
        "# 这里提供经典牛顿作为作业示例\n",
        "def newton_standard(f, df, x0, stop: Stop = Stop()):\n",
        "    \"\"\"\n",
        "    经典牛顿法（Newton's method）\n",
        "    x_{k+1} = x_k - f(x_k) / f'(x_k)\n",
        "\n",
        "    参数\n",
        "    ----\n",
        "    f, df : callable\n",
        "        标量函数与其导数\n",
        "    x0 : float\n",
        "        初始值（需落在收敛域内）\n",
        "    stop : Stop\n",
        "        统一停止准则（xtol/rtol/ftol/maxit）\n",
        "\n",
        "    返回\n",
        "    ----\n",
        "    Result(root, iters, success, status, history, f_calls, df_calls, elapsed_sec)\n",
        "    \"\"\"\n",
        "    t0 = time.perf_counter()\n",
        "    f_calls = 0\n",
        "    df_calls = 0\n",
        "\n",
        "    x = float(x0)\n",
        "    fx = f(x)\n",
        "    f_calls += 1\n",
        "    history = [x]\n",
        "\n",
        "    # 若一开始就满足残差阈值，直接返回\n",
        "    if res_stop(fx, stop):\n",
        "        t1 = time.perf_counter()\n",
        "        return Result(\n",
        "            x, 0, True, \"init_converged(res)\", history, f_calls, df_calls, t1 - t0\n",
        "        )\n",
        "\n",
        "    for k in range(1, stop.maxit + 1):\n",
        "        dfx = df(x)\n",
        "        df_calls += 1\n",
        "        if not np.isfinite(dfx) or dfx == 0.0:\n",
        "            t1 = time.perf_counter()\n",
        "            return Result(\n",
        "                x,\n",
        "                k - 1,\n",
        "                False,\n",
        "                \"derivative_zero_or_nonfinite\",\n",
        "                history,\n",
        "                f_calls,\n",
        "                df_calls,\n",
        "                t1 - t0,\n",
        "            )\n",
        "\n",
        "        # 经典牛顿步\n",
        "        step = fx / dfx\n",
        "        xn = x - step\n",
        "        fn = f(xn)\n",
        "        f_calls += 1\n",
        "\n",
        "        # 数值健壮性条件\n",
        "        if not np.isfinite(fn):\n",
        "            t1 = time.perf_counter()\n",
        "            return Result(\n",
        "                x,\n",
        "                k - 1,\n",
        "                False,\n",
        "                \"f_nonfinite_after_step\",\n",
        "                history,\n",
        "                f_calls,\n",
        "                df_calls,\n",
        "                t1 - t0,\n",
        "            )\n",
        "\n",
        "        x_old, x, fx = x, xn, fn\n",
        "        history.append(x)\n",
        "\n",
        "        # 实现两类停止：步长 & 残差\n",
        "        if step_stop(x, x_old, stop):\n",
        "            t1 = time.perf_counter()\n",
        "            return Result(\n",
        "                x, k, True, \"converged(step)\", history, f_calls, df_calls, t1 - t0\n",
        "            )\n",
        "        if res_stop(fx, stop):\n",
        "            t1 = time.perf_counter()\n",
        "            return Result(\n",
        "                x, k, True, \"converged(res)\", history, f_calls, df_calls, t1 - t0\n",
        "            )\n",
        "\n",
        "    # 达到迭代上限\n",
        "    t1 = time.perf_counter()\n",
        "    return Result(x, stop.maxit, False, \"maxit\", history, f_calls, df_calls, t1 - t0)\n",
        "\n",
        "\n",
        "# ======以下是测试======\n",
        "\n",
        "# 示例：f(x)=cos x - x\n",
        "f1 = lambda x: math.cos(x) - x\n",
        "df1 = lambda x: -math.sin(x) - 1.0\n",
        "res1 = newton_standard(f1, df1, x0=0.5, stop=Stop())\n",
        "print(\"cosx-x:\", res1)\n",
        "\n",
        "# 可视化略\n",
        "\n",
        "# 误差衰减示意\n",
        "xstar1 = 0.73908513321516064166  # 真实值\n",
        "errs1 = np.abs(np.array(res1.history) - xstar1)\n",
        "print(\"last |f|:\", abs(f1(res1.root)), \" last |e|:\", errs1[-1])"
      ],
      "id": "b63a4bb0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## JAX 附录：可微与可编译循环\n",
        "\n",
        "* **开启 64-bit**：`jax.config.update(\"jax_enable_x64\", True)`\n",
        "* `grad` 自动微分、`lax.while_loop` 可编译的循环、`vmap` 批量初值并行\n",
        "* 说明：本课程仅涉及 **CPU 版 JAX**\n",
        "\n",
        "### JAX 牛顿"
      ],
      "id": "8c91424c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import jax, jax.numpy as jnp\n",
        "from jax import grad, jit, vmap, lax\n",
        "\n",
        "jax.config.update(\"jax_enable_x64\", True)\n",
        "\n",
        "\n",
        "def newton_jax(f, x0, xtol=1e-12, ftol=1e-12, maxit=50):\n",
        "    df = grad(f)\n",
        "\n",
        "    def cond(state):\n",
        "        x, x_prev, k = state\n",
        "        step_ok = jnp.abs(x - x_prev) > xtol * (1 + jnp.abs(x))\n",
        "        res_ok = jnp.abs(f(x)) > ftol\n",
        "        return (k < maxit) & (step_ok | res_ok)\n",
        "\n",
        "    def body(state):\n",
        "        x, x_prev, k = state\n",
        "        g = df(x)\n",
        "        # 防护：导数过小则不再移动\n",
        "        step = jnp.where(jnp.abs(g) > 1e-30, f(x) / g, 0.0)\n",
        "        xn = x - step\n",
        "        return (xn, x, k + 1)\n",
        "\n",
        "    x0 = jnp.asarray(x0)\n",
        "    x, _, k = lax.while_loop(cond, body, (x0, x0 + 10 * xtol, 0))\n",
        "    return x, k\n",
        "\n",
        "\n",
        "# 示例\n",
        "f = lambda x: jnp.cos(x) - x\n",
        "x, it = newton_jax(f, 0.5)\n",
        "x, it"
      ],
      "id": "3bd8460b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### `vmap` 批量初值 & 收敛次数图\n",
        "\n",
        "观察不同初值的**收敛速度**不同。有些区域可能迭代上限触顶"
      ],
      "id": "157d8253"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 在一批初值上并行跑牛顿，观察收敛迭代次数\n",
        "xs0 = jnp.linspace(-1.0, 1.0, 401)\n",
        "sol = vmap(lambda x0: newton_jax(f, x0))(xs0)\n",
        "roots, iters = sol\n",
        "\n",
        "# 可视化\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "iters_np = np.asarray(iters)\n",
        "plt.figure(figsize=(8, 2))\n",
        "plt.imshow(iters_np[None, :], aspect=\"auto\", extent=[xs0[0], xs0[-1], 0, 1])\n",
        "plt.yticks([])\n",
        "plt.xlabel(\"initial guess x0\")\n",
        "plt.title(\"Newton iterations across initial guesses\")\n",
        "plt.colorbar(label=\"#iterations\")\n",
        "plt.show()"
      ],
      "id": "53d9d7b0",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/macops/edu/numerical-methods-2025/.venv/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}